{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      \"C++语言学习笔记\"\r\nintro:   \"\"\r\ndate:       2019-11-19 16:00:00\r\nauthor:     \"Makinohara\"\r\nfeatured_image: http://msfasr.com//img/cpp.jpg\r\ncatalog: true\r\ntags:\r\n    - 编程语言\r\n---\r\n\r\n[TOC]\r\n\r\n\r\n\r\n> I'm refactoring this note into English version. This may spend me lots of time.\r\n>\r\n> But I believe it will be a good form for me to learn English.\r\n>\r\n> Carry on! \r\n\r\n# C++ Language Studying(Section 1)\r\n\r\n## Basic C++ Knowledge\r\n\r\n### Some tiny knowledge points\r\n\r\n1B=8bit(B refers byte and b refers bit)\r\n\r\n## C++ I/O\r\n\r\n\r\n\r\n## C++ Sentences\r\n\r\n#### Range for\r\n\r\n```c++\r\nfor(auto s:str1)\r\n{\r\n    cout<<S<<endl;\r\n}\r\n```\r\n\r\nBy using range for, you can process each element in an array or a sequence .\r\n\r\n## C++ 类\r\n\r\n众所周知，支持面向对象编程是C++的一个重要特性，接下来我们来看类。\r\n\r\n```c++\r\nclass Box\r\n{\r\n   public:\r\n      double length;   // 盒子的长度\r\n      double breadth;  // 盒子的宽度\r\n      double height;   // 盒子的高度\r\n};\r\n```\r\n\r\n带成员函数声明和定义：\r\n\r\n```c++\r\nclass Box\r\n{\r\n   public:\r\n      double length;   // 长度\r\n      double breadth;  // 宽度\r\n      double height;   // 高度\r\n      // 成员函数声明\r\n      double get(void);\r\n      void set( double len, double bre, double hei );\r\n};\r\n// 成员函数定义\r\ndouble Box::get(void)\r\n{\r\n    return length * breadth * height;\r\n}\r\n \r\nvoid Box::set( double len, double bre, double hei)\r\n{\r\n    length = len;\r\n    breadth = bre;\r\n    height = hei;\r\n}\r\n```\r\n\r\n### 析构函数：\r\n\r\n```c++\r\nclass String{\r\nprivate:\r\n    char* p;\r\npublic:\r\n    String(int n);\r\n    ~String();\r\n};\r\nString::~String(){   //析构函数\r\n    delete[] p;\r\n}\r\nString::String(int n){\r\n    p = new char[n];\r\n}\r\n```\r\n\r\n\r\n\r\n### c++继承\r\n\r\n```c++\r\n// 基类\r\nclass Shape \r\n{\r\n   public:\r\n      void setWidth(int w)\r\n      {\r\n         width = w;\r\n      }\r\n      void setHeight(int h)\r\n      {\r\n         height = h;\r\n      }\r\n   protected:\r\n      int width;\r\n      int height;\r\n};\r\n \r\n// 派生类\r\nclass Rectangle: public Shape\r\n{\r\n   public:\r\n      int getArea()\r\n      { \r\n         return (width * height); \r\n      }\r\n};\r\n\r\n//多继承\r\nclass <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…\r\n{\r\n<派生类类体>\r\n};\r\n```\r\n\r\n\r\n\r\n重载：\r\n\r\n```c++\r\n//运算符重载：\r\nBox operator+(const Box& b)\r\n      {\r\n         Box box;\r\n         box.length = this->length + b.length;\r\n         box.breadth = this->breadth + b.breadth;\r\n         box.height = this->height + b.height;\r\n         return box;\r\n      }\r\n\r\n//函数重载：\r\nclass printData\r\n{\r\n   public:\r\n      void print(int i) {\r\n        cout << \"整数为: \" << i << endl;\r\n      }\r\n \r\n      void print(double  f) {\r\n        cout << \"浮点数为: \" << f << endl;\r\n      }\r\n \r\n      void print(char c[]) {\r\n        cout << \"字符串为: \" << c << endl;\r\n      }\r\n};\r\n```\r\n\r\n\r\n\r\n## 命名空间\r\n\r\n```c++\r\n// 第一个命名空间\r\nnamespace first_space{\r\n   void func(){\r\n      cout << \"Inside first_space\" << endl;\r\n   }\r\n}\r\n// 第二个命名空间\r\nnamespace second_space{\r\n   void func(){\r\n      cout << \"Inside second_space\" << endl;\r\n   }\r\n}\r\nint main ()\r\n{\r\n \r\n   // 调用第一个命名空间中的函数\r\n   first_space::func();\r\n   \r\n   // 调用第二个命名空间中的函数\r\n   second_space::func(); \r\n \r\n   return 0;\r\n}\r\n```\r\n\r\n## 王氏C++——应付考试内容\r\n\r\n```c++\r\n//自由函数与成员函数，运算符重载的不同\r\n\r\n#include<bits/stdc++.h>\r\nclass complex{\r\n    public:\r\n    complex(int ri = 0, int ii = 0){\r\n        r = ri;\r\n        i = ii;\r\n    }\r\n    int r;\r\n    int i;\r\n    friend complex operator+(const complex &b) ;//友元函数\r\n    //complex operator+(const complex &b) const;  成员函数\r\n};\r\n\r\ncomplex operator+(const complex &a,const complex &b) {\r\n    return complex(a.r+b.r,a.i+b.i);\r\n}\r\n\r\n/*\r\n成员函数\r\ncomplex complex::operator+(const complex &b) const{\r\n    return complex(r+b.r,i+b.i);\r\n}\r\n*/\r\n\r\nint main(){\r\n    complex c1(1,1);\r\n    complex c2(2,2);\r\n    complex c3 = c1+c2;\r\n    complex c4 = c2+3;//成员函数无法执行此操作，而友元函数会得出结果c4.r = c2.r+3,c4.r = c2.r;\r\n    return 0;\r\n}\r\n\r\n//有关数组一说\r\nfloat[2] x[100];//这是每个元素为2个float元素为元素的数组的数组。但是是错的，编译不通过。\r\n```\r\n\r\n### 引用：\r\n\r\n```c++\r\nint x = 5;\r\nint &rx = x;\r\n//rx = 7->x = 7\r\n```\r\n\r\n### 函数：\r\n\r\n```c++\r\ndatatype func_name(datatype a){\r\n\t\r\n}\r\n\r\ndatatype func_name(datatype &rr){\r\n    rr = 2;\r\n}\r\n\r\ndatatype func_name(const float &rr){\r\n    rr = 2;//ERROR\r\n}\r\n\r\n//example:\r\nint fun(int &i){\r\n    i = 36;\r\n    return i;\r\n}\r\n\r\nint main(){\r\n    int i = 3;\r\n    int f = fun(i);\r\n    return 0;\r\n}\r\n\r\n//数组名做参数\r\nint calcsum(int x[],int size){\r\n    int sum;\r\n    for (int i = 0; i < size; i++)\r\n    {\r\n        sum+=x[i];\r\n    }\r\n    return sum;\r\n}\r\n\r\nint main(){\r\n    int x[2]={1,2};\r\n    int sum = calcsum(x,2);\r\n    return 0;\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n### 有关类的四个基本函数\r\n\r\n```c++\r\nclass Clock{\r\n    private:\r\n    int a;\r\n    int b;\r\n    public:\r\n    clock(int a, int b);//构造函数\r\n    clock();//默认构造函数\r\n    clock(int i,int j){\r\n        a = i;\r\n        b = j;\r\n    }\r\n    \r\n    //初始化列表：\r\n    clock(int s, int i):a(s), b(i){};\r\n    \r\n    //析构函数\r\n    ~clock;\r\n    \r\n    //拷贝构造函数\r\n    clock(const clock &c){\r\n        a = c.a;\r\n        b = c.b;\r\n    }\r\n    \r\n    //拷贝赋值函数\r\n    clock& operator=(const clock &c){\r\n        if (&c!= this){   //避免自己拷贝自己的情况\r\n            a = c.a;\r\n            b = c.b;\r\n        }\r\n        return *this;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n### 常函数：\r\n\r\n\r\n\r\n```c++\r\nclass circle{\r\n    private:\r\n    int r;\r\n    public:\r\n    int getR(){\r\n        return r;\r\n    }\r\n    circle(int i){\r\n        r = i;\r\n    }\r\n\r\n    float getArea() /*(const)*/{\r\n        return 3.1415926 *r*r;\r\n    }\r\n    float getAreaC() const){\r\n        return 3.1415926 *r*r;\r\n    }\r\n};\r\n\r\n\r\n\r\nint main(){\r\n    const circle c1(1);\r\n    float area = c1.getArea();//错误，不是常函数无法访问const修饰的对象\r\n    float area = c1.getAreaC();//正确\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n### 继承：\r\n\r\n```c++\r\nclass circle2:/*(private or protected or public)*/circle{\r\n    ......\r\n}\r\n```\r\n\r\n### 虚函数：\r\n\r\n```c++\r\n#include<iostream>\r\n\r\nclass Base1{\r\n\tpublic:\r\n    virtual void display() const;\r\n};\r\n\r\nvoid Base1::display() const{\r\n    std::cout<<1<<std::endl;\r\n}\r\n\r\nclass Base2:public Base1{\r\n    public:\r\n    void display() const ;\r\n};\r\nvoid Base2::display() const{\r\n    std::cout<<2<<std::endl;\r\n}\r\n\r\nvoid function(Base1 *ptr){//一个指向父类的指针\r\n    ptr->display();\r\n}\r\n\r\nint main(){\r\n    Base1 b1;\r\n    Base2 b2;\r\n    function(&b1);//调用 void Base1::display() const\r\n    function(&b2);//调用 void Base2::display() const\r\n}\r\n```\r\n\r\n三种继承方式：父类成员对子类的可见性：\r\n\r\n| 父类访问控制/继承方式： | public    | protected | private |\r\n| ----------------------- | --------- | --------- | ------- |\r\n| public                  | public    | protected | private |\r\n| protected               | protected | protected | private |\r\n| private                 | private   | private   | private |\r\n\r\n\r\n\r\n## C++ Variable\r\n\r\n#### C++ Variable types:\r\n\r\n| Type        | Implication                                   | size                 |\r\n| ----------- | --------------------------------------------- | -------------------- |\r\n| bool        | bool type                                     | undefined            |\r\n| char        | character                                     | 8b                   |\r\n| wchar_t     | wide character                                | 16b                  |\r\n| char16_t    | Unicode character                             | 16b                  |\r\n| char32_t    | Unicode character                             | 32b                  |\r\n| short       | short integer                                 | 16b                  |\r\n| int         | integer                                       | 16b                  |\r\n| long        | long integer                                  | 32b                  |\r\n| long long   | long long integer                             | 64b                  |\r\n| float       | single-precision floating point number        | 6 significant digit  |\r\n| double      | double-precision floating point number        | 10 significant digit |\r\n| long double | expand double-precision floating point number | 10 significant digit |\r\n\r\nUse `unsigned` to state an unsigned variable type, an unsigned variable do not have a sign digit.\r\n\r\n#### Type conversion\r\n\r\n```c++\r\nbool a =42;// 0 refers true and the others refer false.\r\nint i =3.14;// the value of i is 3,the fractional digit has been dropped.\r\ndouble pi =i;//the value of pi is 3\r\nunsigned char c = -1; //the value of c is 255\r\n```\r\n\r\n`WARNING`: **DO NOT USE UNSIGNED TYPE AND  SIGNED TYPE VARIABLE AT THE SAME TIME !!!**\r\n\r\n#### Reference\r\n\r\n```c++\r\nint a=3;\r\nint &num = a;// num is a reference of a\r\nint &num2;//ERROR: reference must be initialized\r\n```\r\n\r\n#### Pointer\r\n\r\nPointers point to a pointer:\r\n\r\n```c++\r\nint a=1024;\r\nint *ptr1 = &a;\r\nint **ptr2 = &ptr1;\r\ncout<<**ptr2<<endl;// output 1024\r\n```\r\n\r\nC++ Standard Library :: begin, end\r\n\r\n```c++\r\nint ia[]={1,2,3,4,5,6,7,8,9};\r\nint *beg = begin(ia);//refer a[0]\r\nint *end = end(ia);//refer the next position after the last element of an array\r\n```\r\n\r\nPointer with custom size:\r\n\r\n```c++\r\nint a[2][2];\r\nint *p[2];//NOT THIS: It created a pointer array\r\nint (*p2)[2];//a pointer which can point to an array with 2 ints.\r\n//use decltype or auto:\r\ndecltype *p3 = a;\r\n```\r\n\r\n\r\n\r\n#### Const\r\n\r\nYou can use `const` to make a variable unchangeable.\r\n\r\n**Top-level-const and Low-level-const:**\r\n\r\n```c++\r\nint i=0;\r\nint *const p1 = &i;//the value of pointer can not be changed,top-level-const\r\nconst int ci =42;//the value of ci can not be changed.\r\nconst int *p2 = &ci;//the value of pointer can not be changed\r\n```\r\n\r\n#### Typedef\r\n\r\n```c++\r\ntypedef double wages;\r\n```\r\n\r\n#### Decltype\r\n\r\nUse decltype to get a type that a function returns.\r\n\r\n```c++\r\ndecltype(f()) sum =0;//the type of sum is just the type that f() returns.\r\n```\r\n\r\n#### Write your own head file\r\n\r\nYou'd better define your struct and class in a head file .\r\n\r\n## Data Structure(STL)\r\n\r\n#### Using statement\r\n\r\nBefore using C++ Standard Library, you can:\r\n\r\n```c++\r\n//method 1\r\nstd::cout<<\"Test\"<<std::endl;\r\n//method 2:\r\nusing namespace std;\r\ncout<<\"123\"<<endl;\r\n```\r\n\r\n\r\n\r\n#### Using iterator\r\n\r\nA sort of intelligence pointer , used for STD .\r\n\r\nC++ example:\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    vector<int> vec1;//Statement\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        vec1.push_back(i);\r\n    }\r\n    auto it = vec1.begin();//Auto Statement\r\n    vector<int>:: iterator it = vec1.begin();//Standard statement\r\n\r\n    cout << *it << endl;\r\n    for (; it != vec1.end(); it++)\r\n    {\r\n        cout << *it << endl;\r\n    }\r\n    \r\n    return 0;\r\n    \r\n}\r\n```\r\n\r\nOperations:\r\n\r\n```c++\r\nit = v1.begin();//set v1 refer to the first\r\n*it;//return value\r\nit++;//point to the next\r\n*it = 1234;//change value\r\nit2 = it + 2;//send the address + 2 to another\r\n```\r\n\r\n\r\n\r\n#### Stack: a LIFO(Last in First out) data structure\r\n\r\nStatement in C++:\r\n\r\n```c++\r\nstack<int> stack_name;\r\n```\r\n\r\nBasic operations:\r\n\r\n```c++\r\nstack_name.push(data);//push a data into the stack\r\ncout<<stack_name.top();//read the data at top\r\nstack_name.pop();//pop out the data at top\r\n```\r\n\r\n#### Queue: a FIFO(First in First out) data structure\r\n\r\nStatement in C++:\r\n\r\n```c++\r\nqueue<int> q;\r\n```\r\n\r\nBasic operations:\r\n\r\n```c++\r\nq.front();//read the data at the front\r\nq.push();//push a data at the end of the queue\r\nq.pop();//pop out the data at the front\r\nq = queue<int>();//empty the queue\r\n```\r\n\r\nThen, let's see a sample of using queue.\r\n\r\nCruel torture (AHU77)\r\n\r\n------\r\n\r\nPlease read the question at [bofcOJ](oj.bofc.tech)\r\n\r\n------\r\n\r\nCode:\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int qty_children = 0, k;\r\n    cin >> qty_children >> k;\r\n\r\n    \r\n    int sum = 0;\r\n    queue<int> children;\r\n    for (int i = 1; i <= qty_children; i++)\r\n    {\r\n        children.push(i);\r\n    } //statement queue\r\n    while (sum < qty_children-1)\r\n    {\r\n\r\n        for (int i = 0; i < k-1; i++)\r\n        {\r\n            children.push(children.front());//if we do not pull out the line, thus we let this wild kid get to the back.\r\n            children.pop();\r\n        }\r\n        children.pop();//when it comes to pull out the line, this wild kid is over.\r\n        sum++;\r\n    }\r\n    cout << children.front();\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n#### Using dynamic array with pointer\r\n\r\nCode demo:\r\n\r\n```c++\r\nint *p = new int[10];//Create an array when running.\r\ndelete[] p;//the realease of a dynamic array method is not same with a variable\r\n```\r\n\r\n#### bitset\r\n\r\nA data structure which storages bit.\r\n\r\n```c++\r\n    bitset<4> bitset1;//construct without parameter:set space 4\r\n\r\n    bitset<8> bitset2(12);//the space is 8, storge 12 into binary system,use 0 to fill the blank bit.\r\n\r\n    string s = \"100101\";\r\n    bitset<10> bitset3(s);//the space is 10,use 0 to fill the blank bit,the string CAN ONLY CONTAINS 0 and 1.\r\n    \r\n    char s2[] = \"10101\";\r\n    bitset<13> bitset4(s2);//the space is 13,use 0 to fill the blank bit\r\n\r\n    cout << bitset1 << endl;//0000\r\n    cout << bitset2 << endl;//00001100\r\n    cout << bitset3 << endl;//0000100101\r\n    cout << bitset4 << endl;//0000000010101\r\n    bitset3[0];//Simular as array,use subscript to access the elements.\r\n    \r\n```\r\n\r\nThere's so many ways to use bitset, but let's see struct first.\r\n\r\n#### Struct\r\n\r\nA struct is a data structure which contains serval variable type. The struct can also form an array!\r\n\r\nC++ examples\r\n\r\n```c++\r\nstruct Books\r\n{\r\n   char  title[50];\r\n   char  author[50];\r\n   char  subject[100];\r\n   int   book_id;\r\n} book = {\"C Language\", \"RUNOOB\", \"Programing Language\", 123456};//define a struct and initialize\r\n\r\n\r\n```\r\n\r\n//Of course, you can use it as below: No initialize.\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nstruct student //define the struct of single student\r\n{\r\n    int number;\r\n    int score;\r\n};\r\n\r\nint main()\r\n{\r\n\tstudent students[10000];\r\n       for (int i = 0; i < total; i++) //input scores\r\n      {\r\n        cin >> students[i].number >> students[i].score;//See the examples here!\r\n      }\r\n\r\n    return 0;\r\n\r\n}\r\n//It means you can only define a struct and use it as a data type!\r\n```\r\n\r\n##### Struct pointer\r\n\r\n```c++\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\nstruct student //define the struct of single student\r\n{\r\n    int number;\r\n    int score;\r\n};\r\n\r\nint main()\r\n{\r\n    struct student students[100];\r\n\r\n    scanf(\"%d%d\", &students[0].number, &students[0].score); //See the examples here!\r\n\r\n    struct student *p = students; //initialize the pointer.\r\n    printf(\"%d\", p->number);      \r\n    p++;                          //go to next student.\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\nstruct student\r\n{\r\n    int id;\r\n    int maths;\r\n};\r\n\r\nint main()\r\n{\r\n    struct student stu1[2];\r\n    struct student *p ;\r\n    p=stu1;\r\n    \r\n    printf(\"%d\",p->id);\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n#### Vector\r\n\r\nThis is a significant data structure in  C++ standard library , equals an array that can change memory size at will,and you can also CRUD in it in will.\r\n\r\nBasic operations:\r\n\r\n```c++\r\nvector<int> c;\r\nc.push_back(1);//place the element at the end of the vector.\r\n\r\n```\r\n\r\n```c++\r\nvector<Sales_item> sales_vec;//vector can also store class or struct\r\nvector<vector<string>>;//the elements in this vector are also vector objects.\r\n```\r\n\r\nOther operations:\r\n\r\n```c++\r\nvector<T> v1{1,2,3,4,5};\r\nvector<T> v2(5,5);//{5,5,5,5,5}\r\nvector<string> v3={\"Hello\",\"World\",\"!\"};\r\nvector<int> v4(10); //Create a vector have 10 elements, initialized by 0.\r\nv4.push_back(1);//put an elemnet to the back of the vector;\r\nv4.size();\r\n```\r\n\r\nUse array to initialize a vector \r\n\r\n```c++\r\nint a[]={1,2,3,4,5};\r\nvector<int> v1(begin(a),end(arr));//send the begin and end to construct.\r\n```\r\n\r\n\r\n\r\n#### String\r\n\r\nString is a **char** sequence whose size is changeable .\r\n\r\nInitialize:\r\n\r\n```c++\r\nstring s1;//an empty string has been created\r\nstring s2(10,'c');//\"cccccccccc\"\r\n```\r\n\r\nOperations:\r\n\r\n| Operation | Action                          |\r\n| --------- | ------------------------------- |\r\n| os<<s;    | Write s to ostream              |\r\n| is>>s;    | Write instream to s             |\r\n| s.size(); | Return the length;              |\r\n| s1+s2     | Connect two strings             |\r\n| s1>=s2    | compare, use *dictionary order* |\r\n\r\n**Get line**\r\n\r\n```c++\r\nwhile(getline(cin,line)&&line.size()>0)\r\n{\r\n    //code\r\n}\r\n```\r\n\r\n**Character type:**\r\n\r\n```c++\r\ntolower(c);//change into lower size\r\ntoupper(c);//change into upper size\r\n```\r\n\r\n`Warning`: Do not do this:\r\n\r\n```c++\r\nchar a[]=\"fff\";\r\nchar b[]=\"aaa\";\r\nstring c = a+b;//ERROR: you are trying to add two pointers!!!\r\n```\r\n\r\n\r\n\r\n#### Set\r\n\r\nAn example:\r\n\r\n```c++\r\n#include <iostream>\r\n#include <set>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int case_number;\r\n    cin >> case_number; //Input the amount\r\n    set<int> numbers;\r\n    int put_number;\r\n    set<int> :: iterator out_number;\r\n    for (int i = 0; i < case_number; i++) // Input data\r\n    {\r\n        cin >> put_number;\r\n        numbers.insert(put_number);\r\n    }\r\n    cout << numbers.size() << endl;\r\n    int count=0;\r\n    for (out_number = numbers.begin(); out_number != numbers.end(); out_number++) \r\n    {\r\n        \r\n        cout << *out_number ;\r\n        count++;\r\n        if(count <= numbers.size()-1) cout<<\" \";\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nSet can automatically sort, and the elements are strictly diverse .\r\n\r\n#### 优先队列:优先级最高的元素先出的队列\r\n\r\nC++的标准库中包含了一个很好用的数据结构:优先队列.该结构可以将优先级大的元素排到前面.\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tpriority_queue<int> que_apples; //默认使用vector,大的数字优先\r\n\tpriority_queue<int, vector<int>, greater<int>> app_que;//小的数字优先\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n自定义优先级:重载运算符\r\n\r\n```c++\r\nclass Student\r\n{\r\n    int id;\r\n    char name[20];\r\n    bool gender;\r\n    bool operator < (Student &a) const\r\n    {\r\n        return id > a.id;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## STL算法\r\n\r\n#### 快排(sort),包含在algorithm\r\n\r\n这个算法极其牛逼,解放了万千程序员的双手(赞美)!!!\r\n\r\n快排作用的内容:数组/向量容器等\r\n\r\nC++使用实例\r\n\r\n```c++\r\nvector<int> v1;\r\nint numbers[2][5];\r\nstruct student\r\n{\r\n    int number;\r\n    int score;\r\n    string name;\r\n}\r\n//此处省略若干行插入数据代码,让我们假设这这里面有很多数据\r\nsort(v1.begin(),v1.end());//默认从小到大排列\r\nbool compare(int a , int b)//按某种排序方案排序\r\n{\r\n    return a>b;//这样是降序排列\r\n    return numbers[a][0]>numbers[b][0];//还能读取某些数据的元素排列\r\n    return student[a].score>student[b].score;//还能读取某些结构体的成员\r\n}\r\n```\r\n\r\n\r\n\r\n## 常用基础算法(一些很基本的,要背的)\r\n\r\n#### 公因数公倍数\r\n\r\n```c++\r\n#include <stdio.h>\r\n#include <math.h>\r\nint main()\r\n{\r\n    int m, n;\r\n    int s = 0;\r\n    int min = 0;\r\n    scanf(\"%d%d\", &m, &n);\r\n    //最大公约数\r\n    if (m > n)\r\n    {\r\n        s = m;\r\n        min = n;\r\n    }\r\n    else\r\n    {\r\n        s = n;\r\n        min = m;\r\n    }\r\n    while (min != 0)\r\n    {\r\n        int t = s%min;\r\n        s = min;\r\n        min = t;\r\n    }\r\n    printf(\"%d\\n\",s);\r\n    //重置两个数\r\n    if (m > n)\r\n    {\r\n        s = m;\r\n        min = n;\r\n    }\r\n    else\r\n    {\r\n        s = n;\r\n        min = m;\r\n    }\r\n    //公倍数\r\n    for (int i = min;; i += min)\r\n    {\r\n        double resR = (double)i / s;\r\n        int floor = i / s;\r\n\r\n        if ((double)floor == resR)\r\n        {\r\n            printf(\"%d\\n\", i);\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n#### 筛法判断质数\r\n\r\n上代码:\r\n\r\n```c++\r\nbool isPrime(int a)\r\n{\r\n    if (a == 2)\r\n        return true;\r\n    if (a % 2 == 0)\r\n        return false;\r\n    int x = sqrt(a);\r\n    for (int i = 2; i <= x; ++i)\r\n    {\r\n        if (a % i == 0)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n```\r\n\r\n#### 素数的埃式筛法\r\n\r\n先确认一个数是素数,然后划掉其倍数,在找到下一个素数后,再划掉其倍数,最后只剩素数.\r\n\r\n```c++\r\nint main()\r\n{\r\n    int number_list[1000] = {0}; //we can get primes below 1000\r\n    bool break_flag = false;\r\n    number_list[0] = 1;\r\n    int pri = 2;\r\n    while (!break_flag)\r\n    {\r\n        // the non-prime will be mark 1\r\n        int count = pri;\r\n        while (count <= 1000)\r\n        {\r\n            count += pri;\r\n            if (count >= 1000)\r\n                break;\r\n            number_list[count] = 1;\r\n        }\r\n        int temp_pri = pri;\r\n        while (true)\r\n        {\r\n            temp_pri++;\r\n            if (temp_pri >= 999)\r\n            {\r\n                break_flag = true;\r\n                break;\r\n            }\r\n            if (number_list[temp_pri] == 0)\r\n            {\r\n                pri = temp_pri;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < 1000; i++)\r\n    {\r\n        if (number_list[i] == 0)\r\n        {\r\n            cout << i << \" \";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 分解质因数(简便方法)\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <math.h>\r\n//这个程序适合好好阅读并分析\r\nvoid foo(long long int n)\r\n{\r\n    long long int sqr = sqrt(n);//测试质数只需测到平方的取整\r\n    long long int i = 0;\r\n    for(i = 2; i <= sqr; i++)//从2开始测\r\n    {\r\n        if(n % i == 0 && (n /= i))//后面的表达式指的是除i留下剩余部分\r\n        {\r\n            printf(\"%lld \", i--);\r\n        }\r\n    }\r\n    if(n != 1)//不打印1作为因子\r\n    {\r\n        printf(\"%lld\", n);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    long long int n ;\r\n    scanf(\"%lld\", &n);\r\n    foo(n);\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n#### 查找字符(这是C标准库里的内容)\r\n\r\n用于在一个字符串(也就是char数组)中查找指定的字符\r\n\r\n```c++\r\nstrchr(string_name, 'A');//在string name 这个字符串中寻找A这个字符\r\n//返回有多种可能,若找到,返回指向这个字符的指针,否则返回NULL(这个NULL是标识符,不是字符串之类的玩意)\r\n```\r\n\r\n#### 位运算\r\n\r\n位运算是一种直接操作位的运算,其包含多种运算符:\r\n\r\n上代码:\r\n\r\n```c++\r\n<<; //左移运算符,移动时丢弃左边的位,用0补充\r\n\"11110000\"<<\"10000000\";//左移了3位!!!\r\n>>; //右移运算符,移动时丢弃右边的位,左边用0或原来丢弃的左边的位补充!!!\r\n\"11111111\">>\"00001111\";//右移了四位!!!\r\n    \r\n//接下来看看逻辑位运算\r\n~;//按位非,倒置0/1\r\n|;//按位或,有一为1,否则为0\r\n^;//XOR,相同为0,不同为1\r\n&;//AND,都为1才为1,否则为0\r\n\r\n//一些常用的位逻辑运算:\r\nlottabits |= pow(2,3);//打开位,也就是将某一位置为1,其中后面的2的多少次方代表着打开的位置(2的0次方代表右起第一位,以此类推)\r\nlottabits ^= pow(2,3);//切换位:置反\r\nlottabits &= pow(2,3);//关闭位:置0\r\nbool isOpen = lottabits & pow(2,3);//测试某一位是否为1(打开),返回true or false.\r\n```\r\n\r\n"},"__N_SSG":true}