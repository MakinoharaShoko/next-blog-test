{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      \"数据结构2：树、散列、堆、图\"\r\nintro:      \"\"\r\ndate:       2020-2-17 16:13:00\r\nauthor:     \"Makinohara\"\r\ncatalog: true\r\ntags:\r\n\t- 计算机基础\r\n---\r\n\r\n\r\n\r\n\r\n\r\n# 树\r\n\r\n树的一些基本概念:\r\n\r\n1.一棵树是一些结点的集合\r\n\r\n2.树和子树之间通过有向的\"边\"连接.\r\n\r\n3.每一棵子树的根是父根的\"儿子\"而父根是子树的\"父亲\".\r\n\r\n4.没有儿子的结点叫做叶\r\n\r\n5.从一个结点到另一个结点的路径叫做\"序列\",序列的长是路径上边的个数,\r\n\r\n6.结点的深度是从根到结点唯一路径的长.\r\n\r\n7.如果存在一条n1到n2的路径,那么n1是n2的祖先,n2是n1的后裔.若n1!=n2,则n1是n2的真祖先.\r\n\r\n8.树的简单实现:\r\n\r\n```c++\r\nstruct node\r\n{\r\n    object element;\r\n    node *firstchild;\r\n    node *nextsibling;\r\n};\r\n```\r\n\r\n接下来看一个最基本的树型结构:\r\n\r\n## 二叉树\r\n\r\n二叉树的每一个结点都不能超过有两个儿子.但子树皆可能为空.\r\n\r\n二叉树的伪代码:\r\n\r\n```c++\r\nstruct node\r\n{\r\n    int a;\r\n    int b;//这些是结点包含的元素\r\n    node *left;\r\n    node *right;//这些是指向子树的指针\r\n};\r\n```\r\n\r\n表达式树的解释:\r\n\r\n![表达式树](/img/tree1.jpg)\r\n\r\n树有多种遍历方式:\r\n\r\n**中序遍历:**\r\n\r\n依次遍历左,结点,右,并且每一层都这么遍历,最终遍历结果为中缀表达式:\r\n\r\n(a+b\\*c)+((d\\*e+f)*g)\r\n\r\n**后序遍历:**\r\n\r\n先打印左右子树,再打印结点:\r\n\r\na b c * + d e * f + g * +\r\n\r\n构造一个后缀表达式树:\r\n\r\n原理:每读入一个表达式就形成一个新的树.\r\n\r\n参见      *数据结构与算法分析:树*     ,我们下面只考虑代码实现:\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nstruct node //定义一个结点\r\n{\r\n    char elem;\r\n    node *left;\r\n    node *right;\r\n};\r\n\r\nint main()\r\n{\r\n    stack<node *> temp_in; //构建一个栈用于存放指针(建树压栈)\r\n    char char_in;          //构建一个临时变量用于读入(符号或数字)\r\n    node node_arr[10000];  //构建一个数组用于存放树\r\n    int pos = 0;           //构建的结点在数组中的位置(每构建一个结点时更新)\r\n    while (true)\r\n    {\r\n        cin >> char_in;\r\n        if (char_in == '!')\r\n            break;\r\n\r\n        if (char_in != '+' && char_in != '-' && char_in != '*' && char_in != '/') //读取非运算符(正常压栈)\r\n        {\r\n            node_arr[pos].elem = char_in; //把内容写入树\r\n            temp_in.push(&node_arr[pos]); //将指针压入栈\r\n        }\r\n        else\r\n        {\r\n            node_arr[pos].elem = char_in;        //将运算符写入树\r\n            node_arr[pos].right = temp_in.top(); //取为右儿子\r\n            temp_in.pop();                       //弹出\r\n            node_arr[pos].left = temp_in.top();  //取为左儿子\r\n            temp_in.pop();                       //弹出\r\n            //最后将这个树入栈\r\n            temp_in.push(&node_arr[pos]);\r\n        }\r\n        pos++;\r\n    }\r\n    //此时树已经建立成功!!!接下来我们需要尝试以中序遍历和后序遍历来输出这个表达式\r\n    node *print_node = temp_in.top(); //当前读出的根,先将栈顶的表达式读入\r\n    temp_in.pop();//待会还要压进去\r\n    while (true)\r\n    {\r\n        if ((*print_node).left == 0x0)\r\n        {\r\n            cout << (*print_node).elem;//若为最左叶,打印\r\n            if (temp_in.empty())//打印完了要是栈顶为空,则跳出循环\r\n            {\r\n                break;\r\n            }\r\n            cout<<(*temp_in.top()).elem;//将根打印出来\r\n            print_node = (*temp_in.top()).right;//修改读数为栈顶右儿子\r\n            temp_in.pop();//将根从栈顶取出\r\n        }\r\n        else\r\n        {\r\n            temp_in.push(print_node);\r\n            print_node = (*print_node).left;\r\n        }\r\n    } //找到最左侧元素\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n# 图论算法\r\n\r\n## 图的介绍\r\n\r\n图 G=(V,E)由顶点(vertex)的集V和边(edge)的集E组成.\r\n\r\n每一条边是一个点对(v,w),v,w∈V,如果点对有序,图就为有向图.\r\n\r\n当存在(v,w)∈E,v和w邻接.\r\n\r\n边可以有一个权或值.\r\n\r\n路径是一个顶点序列,路径的长为该路径上的边数.一个顶点到自身的路径长度为0.\r\n\r\n一个从顶点到自身的路径叫\"环\",不常见.\r\n\r\n回路指的是W1=Wn的长至少为1的路径,无向图要求边互异.\r\n\r\n## 图的表示\r\n\r\n先考虑有向图的表示:\r\n\r\n用数字对顶点标号:\r\n\r\n![图](/img/graph.jpg)\r\n\r\n1.使用二维数组(邻接矩阵)\r\n\r\nA\\[u][v]表示一条从u到v的边,A\\[u][v]=true指边存在,反之不存在.A\\[u][v]=2可以表示一个边的权.\r\n\r\n2.邻接表表示,若有权也可以附加进去\r\n\r\n| 序号 | 值    |\r\n| ---- | ----- |\r\n| 1    | 2,4,3 |\r\n| 2    | 4,5   |\r\n| 3    | 6     |\r\n| 4    | 6,7,3 |\r\n| 5    | 4,7   |\r\n| 6    | (空)  |\r\n| 7    | 6     |\r\n"},"__N_SSG":true}