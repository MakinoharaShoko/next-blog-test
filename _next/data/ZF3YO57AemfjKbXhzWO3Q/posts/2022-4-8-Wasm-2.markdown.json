{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      WASM + Rust + WebWorker 实现计算器（\r\nintro:   \"\"\r\ndate:       2022-4-8 23:00:00\r\nauthor:     \"Mahiru\"\r\ncatalog: true\r\ntags:\r\n    - 工程开发\r\n---\r\n\r\n## WASM + Rust + WebWorker 实现高性能计算器\r\n\r\n假设我们现在需要执行一个 CPU 负载很大的运算。为了不阻塞主线程，我们希望用 Web Worker 将其放到一个新的线程中进行运算，这样就可以避免阻塞主线程。\r\n\r\n而为了提高这个运算的性能，我们希望用 Rust 编写的 WASM 程序来运算。\r\n\r\n**本文就将实现在 Web Worker 中调用 WASM 进行运算。**\r\n\r\n首先，我们来编写一段 Rust 代码，用于完成实际的计算。\r\n\r\n```rust\r\nextern crate wasm_bindgen;\r\n\r\nuse wasm_bindgen::prelude::*;\r\n\r\n#[wasm_bindgen]\r\nextern \"C\" {}\r\n\r\n#[wasm_bindgen]\r\npub fn wasm_add(a: i32, b: i32) -> i32 {\r\n    a + b\r\n}\r\n```\r\n\r\n然后，将其编译为 WASM ，具体的方法参见我的上一篇博文。\r\n\r\n接下来，我们需要创建一个网页，用于测试我们的函数。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>TestWoker</title>\r\n</head>\r\n<body>\r\n<script type=\"module\" src=\"script.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\n在 `script.js`里面，我们要创建一个 Web Worker。\r\n\r\n```js\r\nif (window.Worker) {\r\n    //加载worker，注意第二个参数要有，否则无法导入 module\r\n    const myWorker = new Worker('./worker.js', {type: 'module'});\r\n    myWorker.postMessage([1, 2]);//发送消息\r\n    myWorker.postMessage([3, 4]);//发送消息\r\n    setTimeout(() => {\r\n        myWorker.postMessage([7, 8])\r\n    }, 1000); //1秒后发送消息，用于在编译完成后使 worker 收到消息。\r\n    myWorker.onmessage = (m) => {\r\n        const data = m.data;\r\n        console.log('data from wasm: ' + data); //拿到 wasm 计算的结果\r\n    }\r\n}\r\n```\r\n\r\n然后在 Web Worker 里面，导入并编译 WASM 程序，在收到消息的时候执行计算，并将结果返回给主线程。\r\n\r\n```js\r\nimport init from './pkg/hello_wasm.js';\r\nimport {wasm_add} from './pkg/hello_wasm.js';\r\n\r\nlet isWasmInit = false; //判断是否完成wasm编译\r\n\r\ninit().then(() => isWasmInit = true); //初始化Wasm（编译）\r\n\r\nonmessage = function (m) {\r\n    const data = m.data;\r\n    if (isWasmInit) { //在接收到 message 时，wasm 已经完成编译。\r\n        console.log('Wasm init before message');\r\n        run();\r\n    } else { //在接收到 message 时，wasm 没有完成编译，所以先编译再执行。\r\n        console.log('Wasm not init before message');\r\n        init().then(() => {\r\n                run();\r\n                isWasmInit = true;\r\n            }\r\n        );\r\n    }\r\n\r\n    function run() {\r\n        const res = wasm_add(data[0], data[1]); //调用具体的 wasm 函数\r\n        postMessage(res);\r\n    }\r\n}\r\n```\r\n\r\n这样，我们就实现了一个**不阻塞主线程的，高性能**的加法。（好像没有什么卵用\r\n\r\n但是想想看，如果这是一个加密或解密算法，或者音视频转码，是不是就很有必要了？\r\n"},"__N_SSG":true}