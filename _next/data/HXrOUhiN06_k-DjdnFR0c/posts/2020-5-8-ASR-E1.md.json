{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      \"KMP算法详解\"\r\nintro:      \"\"\r\ndate:       2020-5-8 11:00:00\r\nauthor:     \"Makinohara\"\r\ncatalog: true\r\ntags:\r\n    - 计算机基础\r\n---\r\n\r\n## KMP理论概要\r\n\r\nKMP字符串匹配算法是一种效率更高的字符串匹配算法。相比于传统算法，由于其主串指针不需要回溯，因此大大减少了匹配需要的时间。\r\n\r\n首先，让我们看看其是如何减少重复的步骤的：\r\n\r\n假如有一字符串S：\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | c    | a    | a    | b    | a    |\r\n\r\n我们想要让字符串“aaba”与其匹配。\r\n\r\n那么，匹配看起来就是这样：\r\n\r\n第一次匹配：\r\n\r\n| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | **c**         | a    | a    | b    | a    |\r\n| a    | a    | b    | **a(不匹配)** |      |      |      |      |\r\n\r\n此时指针回退，主串指针回退至2，模式串回退至1。\r\n\r\n第二次匹配：\r\n\r\n| 1    | 2    | 3               | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | --------------- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | a    | **b**           | c    | a    | a    | b    | a    |\r\n|      | a    | **a（不匹配）** |      |      |      |      |      |\r\n\r\n此时主串指针再次回退。\r\n\r\n可以看出，我们的主串指针在匹配过程中一直在重复读取某一段内容，这是大大有损效率的。若是能使主串指针不回退，只控制模式串指针回退一段距离，这也许可以改善。\r\n\r\n实际上，第二次匹配可以简化为：\r\n\r\n| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | **c**         | a    | a    | b    | a    |\r\n|      |      |      | **a(不匹配)** |      |      |      |      |\r\n\r\n然后是第三次匹配：\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8               |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | --------------- |\r\n| a    | a    | b    | c    | a    | a    | b    | **a**           |\r\n|      |      |      |      | a    | a    | b    | **a(匹配成功)** |\r\n\r\n那么，如何算出模式串指针应当回退多少呢？\r\n\r\n根据KMP算法的核心思想，模式串T拥有一个对应表，用于记录模式串T重复的部分。\r\n\r\n观察以下两个对应表：\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | a    | a    | a    | b    | a    |\r\n| 0    | 1    | 2    | 1    | 2    | 3    | 3    | 4    |\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | b    | c    | d    | e    | f    | g    | h    |\r\n| 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |\r\n\r\n可以看出，1号表格中，在匹配到第8个位置时，若是不匹配，只需要回到4对应的位置继续匹配就可以了，但是2号表格中，每一次匹配都必须要回到位置1重新匹配。\r\n\r\n\r\n\r\n原因在于此：\r\n\r\n| 1       | 2       | 3       | 4    | 5       | 6       | 7       | 8    |\r\n| ------- | ------- | ------- | ---- | ------- | ------- | ------- | ---- |\r\n| ***a*** | ***a*** | ***b*** | a    | ***a*** | ***a*** | ***b*** | a    |\r\n| 0       | 1       | 2       | 1    | 2       | 3       | 3       | 4    |\r\n\r\n可以看到，若是第8个字符不匹配并不影响前3个字符已经匹配成功的事实。因为5、6、7三个字符与1、2、3无异。既然我们已经匹配过a、b、c三个字符了，何必再匹配一次？\r\n\r\n举例说明：\r\n\r\n匹配 “aabaaaabcaabaaaba”与“aabaaaba”\r\n\r\n| 1       | 2       | 3       | 4    | 5        | 6        | 7        | 8              | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\r\n| ------- | ------- | ------- | ---- | -------- | -------- | -------- | -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a       | a       | b       | a    | a        | a        | b        | **c**          | a    | a    | b    | a    | a    | a    | b    | a    |\r\n| a       | a       | b       | a    | **a**    | **a**    | **b**    | **a(不匹配）** |      |      |      |      |      |      |      |      |\r\n| 与5相同 | 与6相同 | 与7相同 |      | **匹配** | **匹配** | **匹配** |                |      |      |      |      |      |      |      |      |\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8                 | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | a    | a    | a    | b    | **c**             | a    | a    | b    | a    | a    | a    | b    | a    |\r\n|      |      |      |      | a    | a    | b    | **a（继续匹配）** | a    | a    | b    | a    |      |      |      |      |\r\n\r\n可以看到，由于我们已经在匹配5、6、7三个字符时确定a、a、b三个字符是匹配的，那么我们就不需要在匹配前三个字符上浪费时间了。\r\n\r\n那么，我们已经知道了如何使用模式串的“特性数组”来减少匹配重复字符上的浪费，但是这个数组怎样计算出来呢？\r\n\r\n综合来看，我们计算此数组的目的就在于减少重复匹配，那么此数组的最大目的就是找出在制定字母之前有多少重复部分。\r\n\r\n如：aabaaaba\r\n\r\n| 1                                                            | 2                      | 3            | 4             | 5            | 6             | 7             | 8              |\r\n| ------------------------------------------------------------ | ---------------------- | ------------ | ------------- | ------------ | ------------- | ------------- | -------------- |\r\n| a                                                            | a                      | b            | a             | a            | a             | b             | a              |\r\n| 0（因为每次匹配都是先使指针+1再匹配，若是第一个字符就不匹配，那么就使指针位置为0，匹配时从第一个开始匹配。） | 1（无论有无重复都为1） | 2（重复了a） | 1（没有重复） | 2（重复了a） | 3（重复了aa） | 3（重复了aa） | 4（重复了aab） |\r\n\r\n由此，推导程序如下：\r\n\r\n```c++\r\nstd::vector<int> getNext(std::string in) {\r\n        std::vector<int> res(in.length() + 1);\r\n        int i = 1, j = 0;\r\n        res[1] = 0;\r\n        while (i < in.length()) {\r\n            if (j == 0 || in[j - 1] == in[i - 1]) {\r\n                i++;\r\n                j++;\r\n                res[i] = j;\r\n            } else\r\n                j = res[j];\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n## KMP再优化：\r\n\r\n我们已经看出KMP算法是如何减少重复匹配来减少匹配时间的。但是，是否有一种更优化的方法呢？\r\n\r\n观察以下字符串：\r\n\r\n"},"__N_SSG":true}