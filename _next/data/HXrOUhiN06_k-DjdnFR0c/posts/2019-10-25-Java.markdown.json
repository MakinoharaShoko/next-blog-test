{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      \"Developing in Java\"\r\nintro:   \"\"\r\ndate:       2019-10-25 08:00:00\r\nauthor:     \"Makinohara\"\r\nfeatured_image: http://msfasr.com/img/Java.jpg\r\ncatalog: true\r\ntags:\r\n    - 编程语言\r\n---\r\n\r\n\r\n\r\n# Java Language\r\n\r\n#### Tiny notes\r\n\r\n1B=8bit\r\n\r\nJava have three systems：\r\n\r\n- Java SE（J2SE）（Java2 Platform Standard Edition）\r\n- Java EE  (J2EE)     (Java 2 Platform,Enterprise Edition)\r\n- Java ME (J2ME)   (Java 2 Platform Micro Edition)\r\n\r\n## Java class\r\n\r\n### The define of a java class\r\n\r\nYou can see it's like C++ class in some ways.\r\n\r\n```java\r\nclass Employee\r\n{\r\n    //status(variable)\r\n    private String name;\r\n    private double salary;\r\n    \r\n    //constructor\r\n    public Employee(String n,double s)\r\n    {\r\n        name = n;\r\n        salary = s;\r\n    }\r\n    \r\n    //method\r\n    public String getName()\r\n    {\r\n        return name;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n##### Class Fields\r\n\r\n```java\r\nprivate String name;//private refers this variable can only access by it's own method.\r\nprivate double salary;\r\n```\r\n\r\n##### Class constructor\r\n\r\n```java\r\npublic Employee(String n , double s)\r\n{\r\n    name =n;\r\n    salary =s;\r\n\r\n\r\n//use constructor:\r\nnew Employee(\"Jamws Bond\",10000);\r\n//there can be serveral constructors in a class.\r\n}\r\n```\r\n\r\n### Constructor\r\n\r\nJava offers several mechanisms of constructing a new object.\r\n\r\nThis function is called as **overloading**. If there's several functions with **same name but different parameters** ,  the complicator will choose a function .This called **overloading resolution** .\r\n\r\nOk, let's see constructor.\r\n\r\n**Default field initialize:**\r\n\r\n```java\r\nEmployee John = new Employee();\r\n```\r\n\r\nAll the number will be 0, boolean will be `false`, object reference will be `null`. \r\n\r\nCaution: This is **not a good habit** to initialize a new object with default field.\r\n\r\n#### **Constructor without parameter:**\r\n\r\n```java\r\npublic Employee()\r\n{\r\n    name =\"\";\r\n    salary =0;\r\n    hireDay =LocalDate.now();\r\n}\r\n```\r\n\r\n#### Explicit field initialize \r\n\r\nYou can initialize field value in the declaration of a class.\r\n\r\nBefore using constructor.\r\n\r\n```java\r\npublic class Employee\r\n{\r\n    private String name =\" \";\r\n    private static int nextId;\r\n    private int id = assignId();\r\n    \r\n    \r\n    private static int assignId()\r\n    {\r\n        int r= nextId;\r\n        nextId++;\r\n        return r;\r\n\t}\r\n}\r\n```\r\n\r\n#### Calling another constructor\r\n\r\nUse **`this`** to call another constructor when you are just using a constructor.\r\n\r\n```java\r\npublic Employee(double s)\r\n{\r\n    this(\"Employee\" + nextId,s);\r\n    nextId++;\r\n}\r\n```\r\n\r\n#### Initialization block\r\n\r\nInitialize field values in the class define.\r\n\r\n```java\r\nclass Employee\r\n{\r\n    //......\r\n    private int Id;\r\n    private String name;\r\n    private double salary;\r\n    //......\r\n    \r\n    //Use initialization block\r\n    {\r\n        id = nextId;\r\n        nextId++;\r\n    }\r\n}\r\n```\r\n\r\n#### Summary\r\n\r\nThe Steps of Calling constrictor\r\n\r\n1.If the constructor calls another, construct by that one.\r\n\r\n2.a. All the field will be initialized by default.\r\n\r\n   b. According to the order in `class defination`, execute field initialize function and initialization block.\r\n\r\n### Class Operation\r\n\r\n##### Use `var` to state a local variable\r\n\r\n```java\r\nvar harry = new Employee(\"Hurry\",5000);\r\n```\r\n\r\n##### **Use `clone` to return a copy of an object**\r\n\r\n```java\r\nreturn (Date) hireDay.clone();\r\n```\r\n\r\nTips: a private field is accessible to an object of same class.\r\n\r\n#### Static\r\n\r\nA field or method which is defined as `static` means there is **ONLY ONE** in the same class.\r\n\r\n```java\r\npublic static final double PI = 3.141592653;\r\n```\r\n\r\nA static method do not use an object. Such as:\r\n\r\n```java\r\nMath.pow(10,3);\r\n```\r\n\r\nA static method can not access fields in an object ,but can access **static field**.\r\n\r\n**Use static initialization block**\r\n\r\n```java\r\nstatic\r\n{\r\n    var generator = new Radom();\r\n    nextId = generator.nextInt(10000);\r\n}\r\n```\r\n\r\n\r\n\r\n#### Main method \r\n\r\nA class can have a main method, but it will not come into effect. It is used to **TEST** a class.\r\n\r\n#### Class Date\r\n\r\n```java\r\nSystem.out.println(new Date());\r\nString s = new Date.toString();\r\nDate deadline;//However,this variable does not refer to any object.\r\ndeadline = new Date();//ok.\r\ndeadline = null;// refer to no object\r\ndeadline = birthday;//they refer to the same object\r\n\r\n```\r\n\r\n**Class LocalDate**\r\n\r\n```java\r\npackage com.msfasr.java_startup;\r\n\r\nimport java.time.DayOfWeek;\r\nimport java.time.LocalDate;\r\n\r\npublic class Calendar {\r\n    public static void main(String[] args)\r\n    {\r\n        LocalDate currentDate = LocalDate.now();\r\n        System.out.println(\"Mon Tue Wed Thu Fri Sat Sun\");\r\n        int month=currentDate.getMonthValue();\r\n        int today=currentDate.getDayOfMonth();\r\n        currentDate = currentDate.minusDays(today-1);\r\n        int dayOfWeek = currentDate.getDayOfWeek().getValue();\r\n        for(int i=0;i<dayOfWeek-1;i++)\r\n            System.out.printf(\"    \");\r\n        while(currentDate.getMonthValue() == month)\r\n        {\r\n            if(currentDate.getDayOfMonth()==today)\r\n            {\r\n                System.out.printf(\"*\");\r\n            }\r\n            else\r\n                System.out.printf(\" \");\r\n            System.out.printf(\"%-3d\",currentDate.getDayOfMonth());\r\n            if(currentDate.getDayOfWeek().getValue()==7)\r\n                System.out.println();\r\n            currentDate = currentDate.plusDays(1);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### Java class methods\r\n\r\n#### Main method\r\n\r\n```java\r\npackage com.msfasr.java_startup;//The code is included in a package\r\n\r\nimport java.util.Scanner;//Inport Scanner for input\r\n\r\n\r\npublic class HelloWorld {//The main method is contained in a class\r\n    public static void main(String[] args) {//Be aware of the define of the main method\r\n        System.out.println(\"Hello,world\");\r\n    }\r\n}\r\n```\r\n\r\n#### Class Methods\r\n\r\n```java\r\npublic static void printCalendar()\r\n{\r\n    ......\r\n}//static method, do not operate fields\r\n\r\npublic void changeFormat()\r\n{\r\n    ......\r\n}//this method must based on an object\r\n```\r\n\r\n\r\n\r\n#### Method parameters\r\n\r\nJava programming language can only **Call by value** .\r\n\r\nHowever, when the parameter is an `OBJECT` , methods can change values of OBJECTS.\r\n\r\n```java\r\npublic static void tripleSalary(Employee x)\r\n{\r\n    x.raiseSalary(200);\r\n}\r\n```\r\n\r\nSo,a method **can**:\r\n\r\nChange the status of an object.\r\n\r\n**Can't**:\r\n\r\nChange values of variable.\r\n\r\nMake an object refer to an new object.\r\n\r\n### Package\r\n\r\nJava package is a sort of set contains several **class**.\r\n\r\nPackage standard name:\r\n\r\ncom.(company name).(project name)\r\n\r\nSuch as:\r\n\r\ncom.msfasr.javaStartup\r\n\r\n#### Importing package\r\n\r\n```java\r\nimport java.util.Scanner;//import a class\r\nimport java.util.*       //import a package\r\n```\r\n\r\nWhen there is a class name used by several package, you need to write the package name when using.\r\n\r\n```java\r\nimport java.util.Date;\r\nimport java.sql.Date;\r\n\r\npublic class Main{\r\n    public static void main(String[] args){\r\n        var deadline = new java.util.Date();\r\n        var today = new java.sql.Date(. . . );\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### Static importing\r\n\r\nBy using static importing, you can import a sort of static method and field.\r\n\r\n```java\r\nimport static java.lang.System.*;\r\n//then, you can use:\r\nout.println(\"123\");//System.out\r\nexit(0);//System.exit\r\n\r\n```\r\n\r\n#### Adding class into a package\r\n\r\n```java\r\npackage com.msfasr.javaStartup;\r\n//......\r\n```\r\n\r\nThe class is now in the package.\r\n\r\n**Class annotation** \r\n\r\n```java\r\n/**\r\n * This class is built for Studying Java!\r\n * This means I will enter a new field!\r\n */\r\n\r\npublic class Main {\r\n\t//......\r\n}\r\n```\r\n\r\n\r\n\r\n### Class Designing tips\r\n\r\n1.Guarantee that the **data** is private.\r\n\r\n2.`Warning`: **You must initialize the field!!!**\r\n\r\n3.Do not use so much basic type variable!!!\r\n\r\n```java\r\n//......\r\nprivate String street;\r\nprivate String city;\r\nprivate String state;//bad\r\n//......\r\n\r\n\r\nprivate class address\r\n{\r\n    private String street;\r\n\tprivate String city;\r\n\tprivate String state;   //good\r\n}\r\n```\r\n\r\n4.not all the fields are changeable.\r\n\r\n5.Resolve the classes with so many responsibility.\r\n\r\n6.The name should refer their responsibility.\r\n\r\n7.Use classes unchangeable at first.\r\n\r\n### Class Inheritance\r\n\r\n#### Class, Superclass, Subclass\r\n\r\n**A subclass define:**\r\n\r\n```java\r\npublic class Manager extends Employee\r\n{\r\n    private double bonus;\r\n    \r\n    private void setBonus(double aBonus)\r\n    {\r\n        bonus=aBonus;\r\n    }\r\n}\r\n```\r\n\r\n#### Covering methods\r\n\r\n```java\r\npublic class Manager extends Employee\r\n{\r\n    //...\r\n    public double getSalary()\r\n    {\r\n        int aSalary= super.getSalary();\r\n        return aSalary + bonus;\r\n    }\r\n}\r\n```\r\n\r\n#### Subclass constructor\r\n\r\n```java\r\npublic class Manager extends Employee\r\n{\r\n    public Manager(String name , double salary, int year, int month, int day)\r\n    {\r\n        super(name,salary,year, month, day);\r\n        bonus = 0 ;\r\n    }\r\n}\r\n```\r\n\r\n#### Class Array with dynamic binding\r\n\r\n```java\r\n//...\r\nManager boss = new Manager(\"Makinohara\",80000000,2001,4,13);\r\nboss.setBonus(200000);\r\n\r\n//then, define an array of employees\r\n\r\nvar staff[] = new Employee[3];\r\n\r\nstaff[0] = boss;\r\nstaff[1] = new Employee(\"Mai\",20000,2000,1,2);\r\nstaff[2] = new Employee(\"Sakuta\",10,2001,4,13);\r\n\r\nfor(Employee e : staff)//for:each circulation\r\n{\r\n    System.out.println(e.getName()+\":\"+e.getSalary);\r\n}\r\n```\r\n\r\nThe compiler will choose the right method to get salary, this is **Dynamic Binding**.\r\n\r\n#### Polymorphism\r\n\r\nIn java, the object variable is **polymorphic**, it means a variable of an object can refer all the **subclass object**. \r\n\r\n#### Java Method Calling\r\n\r\n1. The complier gets the method list of **a class and its superclass**.\r\n\r\n2. The complier confirms the **parameter types** of the method which is being called.\r\n\r\n3. The JVM calls the method.\r\n\r\n#### Stop Inheriting : `final`.\r\n\r\n```java\r\npublic final class Boss extends Manager//the class can't be inheriting\r\n{\r\n    //...\r\n    public final String getName()//the method can't be covered.\r\n    {\r\n        //......\r\n    }\r\n}\r\n```\r\n\r\n### Forced type conversion \r\n\r\nIn *Class Array with dynamic binding*, we created an array contains Manager and Employee. However, the array is a Employee array, so we need to use Forced type conversion to convert a Employee object to a Manager object.\r\n\r\n```java\r\nManager boss = (Manager)staff[0];\r\n```\r\n\r\nBut, when you are trying to convert a object **from top to bottom**, it won't work.\r\n\r\n```java\r\nManager boss = (Manager)staff[1];// Not work\r\n\r\n//So,we can avoid this case by using:\r\nif(staff[1] instanceof Manager)\r\n{\r\n    \r\n    boss = (Manager)staff[1];\r\n    \r\n    //......\r\n}\r\n```\r\n\r\n### Abstract Class\r\n\r\nAbstract class is a sort of class that is more general. Such as Person can contain Employee and Student.\r\n\r\nThe define of an abstract class\r\n\r\n```java\r\npublic abstract class Person\r\n{\r\n    private String name;\r\n    public Person (String name)\r\n    {\r\n        this.name = name;\r\n\t}\r\n    \r\n    public abstract String getName()\r\n    {\r\n        return name;\r\n    }\r\n}\r\n```\r\n\r\n**Instantiation is not allowed in an Abstract class.** It means you can't :\r\n\r\n```java\r\nvar aP = new Person(\"Deja vu\");\r\n// you can do this:\r\n\r\nPerson stu1 = new student(\"Deja vu\",\"Computer Driving\");\r\n```\r\n\r\n### Access modifier\r\n\r\npublic : this method or field can be used by `all classes`.\r\n\r\nprivate: this method or field can only used by the `same class`, not for subclasses.\r\n\r\nprotected: this method or field can used by `this package` and `all subclass`\r\n\r\nno modifier: this method or field can be used by all the methods in the `same package`!!\r\n\r\n### Object: the superclass of all classes\r\n\r\nYou can use a variable whose type is `Object` to refer `objects of all classes`.\r\n\r\n```java\r\nObject obj = new Employee(\"Harry Potter\",300000);\r\n```\r\n\r\nBut, when you are trying to operate the object or using methods, you need to do `type conversing` .\r\n\r\n```java\r\nEmployee e = (Employee)obj;\r\n```\r\n\r\n#### **`equals`**\r\n\r\n`equals` is a method to compare whether two objects are equal.\r\n\r\nThe `equals` method in Class Object is used to compare two objects are equal or not, and if two objects reference are same, the method returns true.\r\n\r\n##### Equals method writing\r\n\r\n###### Standard:\r\n\r\n1. **Reflexivity** : x.equals(x) == true \r\n2. **Symmetry** : x.equals(y) == y.equals(x)\r\n3. **Transitivity** : x.equals(y) == true , y.equals(z) == true -> x.equals(z) == true.\r\n4. **Consistency** : If x and y did not change , the equality do not change.\r\n5. **x.equals(null) == false.**\r\n\r\n###### Advice of designing an equals method\r\n\r\nSee *Core Java Vol.1* , 11th edition , Page 178.\r\n\r\n#### Hash code\r\n\r\nhashcode() : returns an integer , the hash code , that refers the object.\r\n\r\nObject.hash(Obj1,Obj2,......,ObjN) ;\r\n\r\nObject.hashcode(Obj);\r\n\r\n#### toString\r\n\r\nObject.toString(); Print a string that consist of all fields. Needs you write yourself.\t\r\n\r\n#### ArrayList\r\n\r\n```java\r\nArrayList<Employee> staff = new ArrayList<Employee>();\r\n\r\n//add an object:\r\nstaff.add(Object);\r\nstaff.add(new Employee(......));\r\n\r\nstaff.size();//returns the number of objects.\r\n```\r\n\r\n**Compare: ArrayList and Array**\r\n\r\n```java\r\nstuff.set(i,harry);//stuff[i] = hurry\r\nEmployee ep = stuff.get(i);// Employee ep = stuff[i]\r\nstuff.add(i,E);//insert E to position i , move the rest. \r\nstuff.remove(i);//delete Element at position i, move the rest\r\n```\r\n\r\n### Object Wrapper\r\n\r\nWrapper class is a sort of class that **corresponding to basic data types**. \r\n\r\nSuch as:\r\n\r\n```java\r\nvar list = new ArrayList<Integer>();\r\nlist.add(3);          //Autoboxing\r\nint n = list.get(i);  //Autounboxing\r\n```\r\n\r\n## Interface\r\n\r\n### Realize an interface\r\n\r\n\r\n\r\n```java\r\nclass Employee implements Comparable<Employee>\t //在实现接口时加上类名，可以可以防止对Object类型转换\r\n{\r\n    //......\r\n    public int compareTo(Employee other)\r\n    {\r\n        return Double.compare(salary,other.salary);\r\n    }\r\n    //......\r\n}\r\n```\r\n\r\n```java\r\npublic class Main {\r\n\r\n    public static void main(String[] args)  {\r\n        var staff = new Employee[3];\r\n        staff[0] = new Employee(\"Mark\",12000,2020,1,20);\r\n        staff[1] = new Employee(\"Lin\",10000,2020,1,20);\r\n        staff[2] = new Employee(\"Coal\",41230,2020,1,20);\r\n        Arrays.sort(staff);\r\n        return;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n接口不是一种类，所以不能使用new实例化接口。\r\n\r\n接口的一个样例：\r\n\r\n```\r\npublic interface Comparable<T>{\r\n\tdefault int compareTo(T other){  //一种默认方法。\r\n\t\treturn 0;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n### 接口与回调\r\n\r\n一个Listener接口：\r\n\r\n```\r\npublic interface ActionListener\r\n{\r\n\tvoid actionPerformed(ActionEvent event);\r\n}\r\n```\r\n\r\n如果想要调用这个接口，则可以在一个类中实现：\r\n\r\n```\r\nclass TimePrinter implements ActionListener{\r\n\tpublic void actionPerformed(ActionEvent event){          //在类中实现这个接口\r\n\t\tSystem.out.println(123);\r\n\t}\r\n}\r\n```\r\n\r\n实现回调的方法：\r\n\r\n```\r\nvar listener = new TimePrinter;\r\nvar timer = new Timer(1000,listener);\r\n//......\r\n//timer每1000毫秒通知实现了ActionListener接口的类，这个类就会实现接口提供的函数actionPerformed，完成一个回调。\r\n```\r\n\r\n## Lambda 表达式\r\n\r\n一种自定义代码块，用于实现某些计算或执行某些函数\r\n\r\n```\r\n//比如，要计算a.length() - b.length()\r\n(String a, String b)\r\n\t->a.length()-b.length()\r\n//或者：\r\n(String a, String b)->\r\n{\r\n\tif(a.length<b.length)\r\n\t\treturn -1;\r\n\t//......\r\n}\r\n//执行函数：\r\nvar timer = new Timer(1000,event ->System.out.println(event))\r\n```\r\n\r\n使用lambda来使方法实现函数式接口，避免多余的重写方法：\r\n\r\n```\r\npackage com.icsii.interfaceDemo;\r\n\r\npublic interface printer {\r\n    void printString(String something);\r\n}\r\npublic class print {\r\n    public void printSomething(String something,printer aPrinter){\r\n        aPrinter.printString(something);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        print Demo1 = new print();\r\n        Demo1.printSomething(\"123\",(String something)->System.out.println(something));\r\n    }\r\n}\r\n\r\n(接口接收的参数)->{接口实现的方法}\r\n```\r\n\r\n\r\n\r\n## Java I/O\r\n\r\n#### Input(scanner)\r\n\r\nFirstly, import a class *scanner* .\r\n\r\n```java\r\nimport java.util.Scanner;\r\n```\r\n\r\nThis class has these basic operations :\r\n\r\n```java\r\nScanner sc = new Scanner(System.in);//new a scanner\r\nString name = sc.nextLine();//Get a line\r\nint age = sc.nextInt();//Get the next int\r\nsc.close();//Close the scanner when used,or it will report an error.\r\n```\r\n\r\n##### Other measures\r\n\r\n```java\r\nString nextLine();//read next line;\r\nString next();//read next word, use blank as separator.\r\nint nextInt();//read next int\r\nboolean hasNext();//if there's words in line\r\nboolean hasNextInt();\r\n```\r\n\r\n##### Read files\r\n\r\n```java\r\nScanner sc = new Scanner(\"Path\",StandardCharsets.UTF_8);//read file\r\nPrintWriter out = new PrintWriter(\"Path\",StandardCharsets.UTF_8);//Write file\r\nout.print();//Warning: this method will rewrite the file!!!\r\n```\r\n\r\n\r\n\r\n#### Output (System.out)\r\n\r\n```java\r\nSystem.out.println(1111);//Print and return\r\nSystem.out.print(1111);//Print without returning\r\nSystem.out.write(2222);//byte output\r\nSystem.out.printf(\"%+8.3f\\n\", 3.14);//Print according to format\r\n```\r\n\r\n\r\n\r\n## Java variable :\r\n\r\n### Variable types\r\n\r\n| Variable type | value                        |\r\n| ------------- | ---------------------------- |\r\n| int           | 4byte,-2147483648~2147483647 |\r\n| short         | 2byte                        |\r\n| long          | 8byte                        |\r\n| byte          | 1byte                        |\r\n| float         | 4byte                        |\r\n| double        | 8byte                        |\r\n| char(UTF-16)  | 16byte(UTF-16 character )    |\r\n| boolean       | true/false                   |\r\n\r\nCaution: A variable must be initialized ,or the compiler will put an ERROR.\r\n\r\nIn java, key word `final` refers a variable is constant.\r\n\r\n**enum**:\r\n\r\n```java\r\nenum Size {Small,Medium};//enum is a CLASS!\r\nSize s = Size.Small;//it can only use values defined above.\r\n```\r\n\r\n#### String\r\n\r\n**str.substring** can extract a part of string .\r\n\r\n```java\r\nString greeting = \"Hello\";\r\nString s = greeting.substring(0,3);//s = \"Hel\"\r\nString str = greeting+s;\r\n```\r\n\r\n str.equals compares two strings:\r\n\r\n```java\r\n\"Hello\".equals(greeting);\r\n```\r\n\r\nCaution: DO NOT USE == !\r\n\r\n##### Other measures \r\n\r\n```java\r\nstr.length(); //return length\r\nstr.blank(); // judge if the string is empty\r\nstr.join(\"/\",str1,str2,str3......);// use / as separator , combine strings\r\nString.format(\"%f\",a);//returns a String with format\r\n```\r\n\r\n#### Big numbers\r\n\r\n```java\r\nBigInteger;\r\nBigDecimal;\r\nnum1.add(num2);\r\n//use add subtract multiply devide mod\r\n```\r\n\r\n### Array\r\n\r\n```java\r\nint[] a = new int[100];\r\nint[] a = new int[n];\r\nint[] a = {1,3,7,7,9};\r\na = new int[] {1,3,5,7,9};\r\na.length();\r\nArray.sort(a);\r\nArray.binarySearch(xxx[] a,xxx v);\r\nArray.binarySearch(xxx[] a,int start,int end,xxx v);\r\nArray.fill(xxx[] a,xxx v);\r\nint a[][] = new int[1][3];\r\nint[] temp = a[1];\r\na[1]=a[2];\r\na[2]=temp;//exchange 2 lines\r\nint[][] feb = new int[100][];\r\nfor(int n=0;n<100;n++)\r\n    feb[n]=new int[n+1];//regard feb[n] as an array name.\r\n```\r\n\r\n**Array copy:**\r\n\r\n```java\r\nint[] a = {1};\r\nint[] b = a;\r\na[0]=5;//now,b[0] is also 5\r\nint[] ca = Arrays.copyOf(a,5);//then we get a new array, the size is 5.\r\n```\r\n\r\n## Java sentences\r\n\r\n### For\r\n\r\n#### **For each**\r\n\r\n```java\r\nfor(int element:a)\r\n\tSystem.out.println(element);\r\n```\r\n\r\n"},"__N_SSG":true}