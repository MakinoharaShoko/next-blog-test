{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      \"C Programing Language\"\r\nintro:   \"\"\r\ndate:       2019-11-12 10:13:00\r\nauthor:     \"Makinohara\"\r\nfeatured_image: http://msfasr.com/img/post-bg-css.jpg\r\ncatalog: true\r\ntags:\r\n    - 编程语言\r\n---\r\n\r\n> This is a note about The C programing language .\r\n>\r\n> I'm refactoring this note into English, too. \r\n\r\n## C Basic Knowledge\r\n\r\n#### C variable , data types\r\n\r\nC语言中存在已经定义好的数种数据类型,每种数据类型都有其可表示值的范围.\r\n\r\n*接下来要背书了,学个计算机有时候就是和学高中语文一样难受.*\r\n\r\n下表列出了关于标准整数类型的存储大小和值范围的细节：\r\n\r\n| 类型           | 存储大小    | 值范围                                                       |\r\n| :------------- | :---------- | :----------------------------------------------------------- |\r\n| char           | 1 字节      | -128 到 127 或 0 到 255                                      |\r\n| unsigned char  | 1 字节      | 0 到 255                                                     |\r\n| signed char    | 1 字节      | -128 到 127                                                  |\r\n| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 `依环境而定` |\r\n| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295 `依环境而定`               |\r\n| short          | 2 字节      | -32,768 到 32,767                                            |\r\n| unsigned short | 2 字节      | 0 到 65,535                                                  |\r\n| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                              |\r\n| unsigned long  | 4 字节      | 0 到 4,294,967,295                                           |\r\n\r\n下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：\r\n\r\n| 类型        | 存储大小 | 值范围                 | 精度      |\r\n| :---------- | :------- | :--------------------- | :-------- |\r\n| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |\r\n| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |\r\n| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |\r\n\r\n\r\n\r\n#### Functions of Input and Output\r\n\r\n#### scanf\r\n\r\nscanf是格式化输入的函数,可以将用户从键盘输入的内容写到一个地址中去.scanf的使用格式是这样的:\r\n\r\nscanf(\"%d\",&a);\r\n\r\n%d代表输入的是一个整型变量,相类似的还有%f(浮点型变量),%lf(长浮点型变量),%c(字符型变量),%s(字符串).\r\n\r\n### File R/W\r\n\r\n```c\r\n#include<stdio.h>\r\nint main()\r\n{\r\n    //fopen\r\n    FILE *p = fopen(\"filename\",\"r\");\r\n    char str[100] = {0};\r\n    fscanf(p,\"%s\",str);\r\n    \r\n    //freopen\r\n    freopen(\"filename\",\"r\",stdin);\r\n    scanf(\"%s\",str);\r\n}\r\n```\r\n\r\n\r\n\r\n### Preprocessing command\r\n\r\nPreprocessing command normally be placed before the start of function definition. It is used to process something before compile .\r\n\r\n#### Macro definition\r\n\r\nMacro definition normally starts with # , such as:\r\n\r\n```c\r\n#define\r\n#include\r\n```\r\n\r\nThe rules of using macro definition:\r\n\r\n```c\r\n#define PI 3.1415926//不含参数的构造,语句结束不需要分号,#include亦然\r\n//编译器会直接将所有的PI替换为3.1415926\r\n#define R 3.0\r\n#define L 2*PI*R\r\n//以上的两行也是可以的,宏定义会展开.\r\nprintf(\"L\");//格式控制输出时不置反\r\n\r\n#define S(a,b) a*b//含参构造,遇到S(数字,数字),替换为a*b\r\n```\r\n\r\n宏名一般使用大写字母表示,这是一种约定俗成的规则.\r\n\r\n宏定义不会为标识符分配内存空间\r\n\r\n宏定义的终止:\r\n\r\n```c\r\n#undefine PI\r\n```\r\n\r\n#### File includes\r\n\r\n```c\r\n#include<file name>\r\n#include\"file name\"//偏向于用户自定义部分\r\n```\r\n\r\n#### Conditional Compile\r\n\r\n```c\r\n#ifdef //flag\r\n#define LETTER 1\r\n\r\n#if LETTER\r\n//code\r\n#else\r\n//code\r\n```\r\n\r\n### Pointer\r\n\r\nPointer is a sort of variable that storages address.\r\n\r\nHere are some basic operations of using pointer.\r\n\r\n```c\r\nint a=3;\r\nint *ptr = &a;//ptr is a variable that points to the address of a\r\n*ptr;//use * to access the data at the address which ptr points to.\r\n*(ptr++);//returns *ptr,and then ptr++\r\n```\r\n\r\n#### **Use pointer to access array:**\r\n\r\n```c\r\nint a[]={1,2,3,5,2,6,2,5}\r\nint *ptr = &a;//the address of an array is just same as the address of the first element of the array.\r\nprintf(\"%d\",*ptr++); //the ptr++ refers the pointer is going to point to the next element of the array\r\n```\r\n\r\nUse pointer to access multi dimension array;\r\n\r\n| Array    | Use variable | Use pointer  | Use pointer | Use pointer     |\r\n| -------- | ------------ | ------------ | ----------- | --------------- |\r\n| a[i]     | a[i]         | *(a+1)       | *(a+1)      | *(a+i)          |\r\n| a\\[i][j] | a\\[i][j]     | *(\\*(a+i)+j) | *(a[i]+j)   | *(\\&a\\[i][0]+j) |\r\n\r\nAn address like **a** (the array is a\\[3][3]) can't be a value of int *p;\r\n\r\nSo,how to do that?\r\n\r\nUse int (*p)[4] , a pointer of this type can have a value like a (the array is a\\[2][4]).\r\n\r\n#### Pointer Array\r\n\r\n```c\r\nint *p[4];//a define of a pointer array\r\nchar *p[4]={\"Brazil\",\"Russia\",\"India\",\"China\"};//a array of pointer,each points to a string.\r\n```\r\n\r\n**Sort a char *p[]**\r\n\r\n```c\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nint main()\r\n{\r\n    char *p[]={\"Aa\",\"Bb\",\"Cc\",\"Dd\"};\r\n    for(int i=0;i<4;i++)\r\n    {\r\n        int pos =i;\r\n        char max = *p[i];\r\n        for(int j=i;j<4;j++)\r\n        {\r\n            if(*p[j]>max)\r\n            {\r\n                max=*p[j];\r\n                pos=j;\r\n            }\r\n        }\r\n        char* t= p[i];\r\n        p[i]=p[pos];\r\n        p[pos]=t;\r\n    }\r\n\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n#### Dynamic Memory Space\r\n\r\n```c\r\nint *p = (int*)malloc(4);; //set a space whose size is 4.\r\nint *p[4] = (int*)calloc(n,sizeof(int));//set n*size array.\r\nrealloc(p,8);//resize.\r\nfree(p);//delete.\r\n```\r\n\r\n#### Pointer to Pointer\r\n\r\n```c\r\nint **p;\r\n**p=2;\r\n*p;//an address\r\n**p;//a value\r\n```\r\n\r\n#### Parameters to main\r\n\r\n```c\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nint main(int argc,char* argv[])//argc refers string numbers and argv refers string that put in.\r\n    //argv[0]=your program name\r\n{\r\n    for(int i=1;argv[i]!=NULL;i++)\r\n    printf(\"%s\\n\",argv[i]);\r\n\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n### Dynamic Memory space\r\n\r\nMalloc\r\n\r\n```c\r\nint main()\r\n{\r\n    struct Student *head;\r\n    head = (struct Student *)malloc(sizeof(struct Student));\r\n}\r\n```\r\n\r\nCalloc\r\n\r\n```c\r\nint main()\r\n{\r\n    head = (struct Student*)calloc(100,sizeof(struct Student))\r\n}\r\n```\r\n\r\nRealloc\r\n\r\n```c\r\nint main()\r\n{\r\n    realloc(*p,size);\r\n}\r\n```\r\n\r\nFree\r\n\r\n```c\r\nint main()\r\n{\r\n    free(*p);\r\n}\r\n```\r\n\r\nExample:\r\n\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n\r\nstruct Student \r\n{\r\n    int age=0;\r\n    struct Student *next=NULL;\r\n};\r\n\r\nint main()\r\n{\r\n    struct Student *head,*current;\r\n    int i=0;\r\n    head = (struct Student*)malloc(sizeof(struct Student));\r\n    current=head;\r\n    while(i==0)\r\n    {\r\n        printf(\"Add student? 0/yes 1/no\\n\");\r\n        scanf(\"%d\",&i);\r\n        if(i==0)\r\n        {\r\n            printf(\"input age\\n\");\r\n            scanf(\"%d\",&(*current).age);\r\n            (*current).next=(struct Student*)malloc(sizeof(struct Student));\r\n            current = (*current).next;\r\n        }else\r\n        {\r\n            (*current).age=0;\r\n            (*current).next=NULL;\r\n        }\r\n        \r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n## File operation\r\n\r\n#### File pointer\r\n\r\n```c\r\nFILE *fp;//create a pointer point to the head of the file.\r\nfp = fopen(\"file.txt\",\"a+\");//open the file.\r\nfclose(fp);\r\n```\r\n\r\n#### File functions\r\n\r\n```c\r\n//freopen\r\nfreopen(\"File\",\"a+\",stdin);\r\nfreopen(\"File\",\"w\",stdout);\r\nfclose(ptr);//or the file will not be write.\r\n\r\nfgetc(fp);\r\nfputc(ch,fp);\r\n//read and write character in a file.\r\n\r\nfgets(str,n,fp);//See carefully, there's n in parameter list, n refers the string's length is n-1 .\r\nfputs(str,fp);\r\n\r\nfscanf(fp,\"Format\",parameter list);\r\nfprintf(fp,\"Format\",parameter list);\r\n\r\n//read and write in bit\r\nfread(buffer,size,count,fp);\r\nfwrite(buffer,size,count,fp);\r\n\r\n//examples:\r\nfread(&stu_list[i],sizeof(struct student),1,fp);\r\nfwrite(&stu_list[i],sizeof(struct student),1,fp);//you can see it as using disk as memory.\r\n\r\n```\r\n\r\n#### Radom R/W files\r\n\r\n```c\r\nrewind(fp);//move the file flag back to the head.\r\nfseek(fp,100L,0);//move the flag to the position 100 byte away from the head.\r\nfseek(fp,100L,1);//move foward 100 byte from current position\r\nfseek(fp,-50L,3);//move back 50 byte from the end.\r\n```\r\n\r\n| start position   | name     | number reference |\r\n| ---------------- | -------- | ---------------- |\r\n| head             | SEEK_SET | 0                |\r\n| current position | SEEK_CUR | 1                |\r\n| end              | SEEK_END | 2                |\r\n\r\n"},"__N_SSG":true}