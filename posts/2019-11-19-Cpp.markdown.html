<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/876d048b5dab7c28.css" as="style"/><link rel="stylesheet" href="/_next/static/css/876d048b5dab7c28.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-f11614d8aa7ee555.js" defer=""></script><script src="/_next/static/chunks/pages/_app-bf55c49910772dbb.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/557-10798b428373902a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-a468c6c0f66f2931.js" defer=""></script><script src="/_next/static/ZF3YO57AemfjKbXhzWO3Q/_buildManifest.js" defer=""></script><script src="/_next/static/ZF3YO57AemfjKbXhzWO3Q/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><p>[TOC]</p>
<blockquote>
<p>I&#x27;m refactoring this note into English version. This may spend me lots of time.</p>
<p>But I believe it will be a good form for me to learn English.</p>
<p>Carry on!</p>
</blockquote>
<h1>C++ Language Studying(Section 1)</h1>
<h2>Basic C++ Knowledge</h2>
<h3>Some tiny knowledge points</h3>
<p>1B=8bit(B refers byte and b refers bit)</p>
<h2>C++ I/O</h2>
<h2>C++ Sentences</h2>
<h4>Range for</h4>
<pre><code class="language-c++">for(auto s:str1)
{
    cout&lt;&lt;S&lt;&lt;endl;
}
</code></pre>
<p>By using range for, you can process each element in an array or a sequence .</p>
<h2>C++ 类</h2>
<p>众所周知，支持面向对象编程是C++的一个重要特性，接下来我们来看类。</p>
<pre><code class="language-c++">class Box
{
   public:
      double length;   // 盒子的长度
      double breadth;  // 盒子的宽度
      double height;   // 盒子的高度
};
</code></pre>
<p>带成员函数声明和定义：</p>
<pre><code class="language-c++">class Box
{
   public:
      double length;   // 长度
      double breadth;  // 宽度
      double height;   // 高度
      // 成员函数声明
      double get(void);
      void set( double len, double bre, double hei );
};
// 成员函数定义
double Box::get(void)
{
    return length * breadth * height;
}
 
void Box::set( double len, double bre, double hei)
{
    length = len;
    breadth = bre;
    height = hei;
}
</code></pre>
<h3>析构函数：</h3>
<pre><code class="language-c++">class String{
private:
    char* p;
public:
    String(int n);
    ~String();
};
String::~String(){   //析构函数
    delete[] p;
}
String::String(int n){
    p = new char[n];
}
</code></pre>
<h3>c++继承</h3>
<pre><code class="language-c++">// 基类
class Shape 
{
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;
};
 
// 派生类
class Rectangle: public Shape
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};

//多继承
class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…
{
&lt;派生类类体&gt;
};
</code></pre>
<p>重载：</p>
<pre><code class="language-c++">//运算符重载：
Box operator+(const Box&amp; b)
      {
         Box box;
         box.length = this-&gt;length + b.length;
         box.breadth = this-&gt;breadth + b.breadth;
         box.height = this-&gt;height + b.height;
         return box;
      }

//函数重载：
class printData
{
   public:
      void print(int i) {
        cout &lt;&lt; &quot;整数为: &quot; &lt;&lt; i &lt;&lt; endl;
      }
 
      void print(double  f) {
        cout &lt;&lt; &quot;浮点数为: &quot; &lt;&lt; f &lt;&lt; endl;
      }
 
      void print(char c[]) {
        cout &lt;&lt; &quot;字符串为: &quot; &lt;&lt; c &lt;&lt; endl;
      }
};
</code></pre>
<h2>命名空间</h2>
<pre><code class="language-c++">// 第一个命名空间
namespace first_space{
   void func(){
      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func(){
      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;
   }
}
int main ()
{
 
   // 调用第一个命名空间中的函数
   first_space::func();
   
   // 调用第二个命名空间中的函数
   second_space::func(); 
 
   return 0;
}
</code></pre>
<h2>王氏C++——应付考试内容</h2>
<pre><code class="language-c++">//自由函数与成员函数，运算符重载的不同

#include&lt;bits/stdc++.h&gt;
class complex{
    public:
    complex(int ri = 0, int ii = 0){
        r = ri;
        i = ii;
    }
    int r;
    int i;
    friend complex operator+(const complex &amp;b) ;//友元函数
    //complex operator+(const complex &amp;b) const;  成员函数
};

complex operator+(const complex &amp;a,const complex &amp;b) {
    return complex(a.r+b.r,a.i+b.i);
}

/*
成员函数
complex complex::operator+(const complex &amp;b) const{
    return complex(r+b.r,i+b.i);
}
*/

int main(){
    complex c1(1,1);
    complex c2(2,2);
    complex c3 = c1+c2;
    complex c4 = c2+3;//成员函数无法执行此操作，而友元函数会得出结果c4.r = c2.r+3,c4.r = c2.r;
    return 0;
}

//有关数组一说
float[2] x[100];//这是每个元素为2个float元素为元素的数组的数组。但是是错的，编译不通过。
</code></pre>
<h3>引用：</h3>
<pre><code class="language-c++">int x = 5;
int &amp;rx = x;
//rx = 7-&gt;x = 7
</code></pre>
<h3>函数：</h3>
<pre><code class="language-c++">datatype func_name(datatype a){
	
}

datatype func_name(datatype &amp;rr){
    rr = 2;
}

datatype func_name(const float &amp;rr){
    rr = 2;//ERROR
}

//example:
int fun(int &amp;i){
    i = 36;
    return i;
}

int main(){
    int i = 3;
    int f = fun(i);
    return 0;
}

//数组名做参数
int calcsum(int x[],int size){
    int sum;
    for (int i = 0; i &lt; size; i++)
    {
        sum+=x[i];
    }
    return sum;
}

int main(){
    int x[2]={1,2};
    int sum = calcsum(x,2);
    return 0;
}


</code></pre>
<h3>有关类的四个基本函数</h3>
<pre><code class="language-c++">class Clock{
    private:
    int a;
    int b;
    public:
    clock(int a, int b);//构造函数
    clock();//默认构造函数
    clock(int i,int j){
        a = i;
        b = j;
    }
    
    //初始化列表：
    clock(int s, int i):a(s), b(i){};
    
    //析构函数
    ~clock;
    
    //拷贝构造函数
    clock(const clock &amp;c){
        a = c.a;
        b = c.b;
    }
    
    //拷贝赋值函数
    clock&amp; operator=(const clock &amp;c){
        if (&amp;c!= this){   //避免自己拷贝自己的情况
            a = c.a;
            b = c.b;
        }
        return *this;
    }
    
}
</code></pre>
<h3>常函数：</h3>
<pre><code class="language-c++">class circle{
    private:
    int r;
    public:
    int getR(){
        return r;
    }
    circle(int i){
        r = i;
    }

    float getArea() /*(const)*/{
        return 3.1415926 *r*r;
    }
    float getAreaC() const){
        return 3.1415926 *r*r;
    }
};



int main(){
    const circle c1(1);
    float area = c1.getArea();//错误，不是常函数无法访问const修饰的对象
    float area = c1.getAreaC();//正确
    return 0;
}
</code></pre>
<h3>继承：</h3>
<pre><code class="language-c++">class circle2:/*(private or protected or public)*/circle{
    ......
}
</code></pre>
<h3>虚函数：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;

class Base1{
	public:
    virtual void display() const;
};

void Base1::display() const{
    std::cout&lt;&lt;1&lt;&lt;std::endl;
}

class Base2:public Base1{
    public:
    void display() const ;
};
void Base2::display() const{
    std::cout&lt;&lt;2&lt;&lt;std::endl;
}

void function(Base1 *ptr){//一个指向父类的指针
    ptr-&gt;display();
}

int main(){
    Base1 b1;
    Base2 b2;
    function(&amp;b1);//调用 void Base1::display() const
    function(&amp;b2);//调用 void Base2::display() const
}
</code></pre>
<p>三种继承方式：父类成员对子类的可见性：</p>
<p>| 父类访问控制/继承方式： | public    | protected | private |
| ----------------------- | --------- | --------- | ------- |
| public                  | public    | protected | private |
| protected               | protected | protected | private |
| private                 | private   | private   | private |</p>
<h2>C++ Variable</h2>
<h4>C++ Variable types:</h4>
<p>| Type        | Implication                                   | size                 |
| ----------- | --------------------------------------------- | -------------------- |
| bool        | bool type                                     | undefined            |
| char        | character                                     | 8b                   |
| wchar_t     | wide character                                | 16b                  |
| char16_t    | Unicode character                             | 16b                  |
| char32_t    | Unicode character                             | 32b                  |
| short       | short integer                                 | 16b                  |
| int         | integer                                       | 16b                  |
| long        | long integer                                  | 32b                  |
| long long   | long long integer                             | 64b                  |
| float       | single-precision floating point number        | 6 significant digit  |
| double      | double-precision floating point number        | 10 significant digit |
| long double | expand double-precision floating point number | 10 significant digit |</p>
<p>Use <code>unsigned</code> to state an unsigned variable type, an unsigned variable do not have a sign digit.</p>
<h4>Type conversion</h4>
<pre><code class="language-c++">bool a =42;// 0 refers true and the others refer false.
int i =3.14;// the value of i is 3,the fractional digit has been dropped.
double pi =i;//the value of pi is 3
unsigned char c = -1; //the value of c is 255
</code></pre>
<p><code>WARNING</code>: <strong>DO NOT USE UNSIGNED TYPE AND  SIGNED TYPE VARIABLE AT THE SAME TIME !!!</strong></p>
<h4>Reference</h4>
<pre><code class="language-c++">int a=3;
int &amp;num = a;// num is a reference of a
int &amp;num2;//ERROR: reference must be initialized
</code></pre>
<h4>Pointer</h4>
<p>Pointers point to a pointer:</p>
<pre><code class="language-c++">int a=1024;
int *ptr1 = &amp;a;
int **ptr2 = &amp;ptr1;
cout&lt;&lt;**ptr2&lt;&lt;endl;// output 1024
</code></pre>
<p>C++ Standard Library :: begin, end</p>
<pre><code class="language-c++">int ia[]={1,2,3,4,5,6,7,8,9};
int *beg = begin(ia);//refer a[0]
int *end = end(ia);//refer the next position after the last element of an array
</code></pre>
<p>Pointer with custom size:</p>
<pre><code class="language-c++">int a[2][2];
int *p[2];//NOT THIS: It created a pointer array
int (*p2)[2];//a pointer which can point to an array with 2 ints.
//use decltype or auto:
decltype *p3 = a;
</code></pre>
<h4>Const</h4>
<p>You can use <code>const</code> to make a variable unchangeable.</p>
<p><strong>Top-level-const and Low-level-const:</strong></p>
<pre><code class="language-c++">int i=0;
int *const p1 = &amp;i;//the value of pointer can not be changed,top-level-const
const int ci =42;//the value of ci can not be changed.
const int *p2 = &amp;ci;//the value of pointer can not be changed
</code></pre>
<h4>Typedef</h4>
<pre><code class="language-c++">typedef double wages;
</code></pre>
<h4>Decltype</h4>
<p>Use decltype to get a type that a function returns.</p>
<pre><code class="language-c++">decltype(f()) sum =0;//the type of sum is just the type that f() returns.
</code></pre>
<h4>Write your own head file</h4>
<p>You&#x27;d better define your struct and class in a head file .</p>
<h2>Data Structure(STL)</h2>
<h4>Using statement</h4>
<p>Before using C++ Standard Library, you can:</p>
<pre><code class="language-c++">//method 1
std::cout&lt;&lt;&quot;Test&quot;&lt;&lt;std::endl;
//method 2:
using namespace std;
cout&lt;&lt;&quot;123&quot;&lt;&lt;endl;
</code></pre>
<h4>Using iterator</h4>
<p>A sort of intelligence pointer , used for STD .</p>
<p>C++ example:</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main()
{
    vector&lt;int&gt; vec1;//Statement
    for (int i = 0; i &lt; 5; i++)
    {
        vec1.push_back(i);
    }
    auto it = vec1.begin();//Auto Statement
    vector&lt;int&gt;:: iterator it = vec1.begin();//Standard statement

    cout &lt;&lt; *it &lt;&lt; endl;
    for (; it != vec1.end(); it++)
    {
        cout &lt;&lt; *it &lt;&lt; endl;
    }
    
    return 0;
    
}
</code></pre>
<p>Operations:</p>
<pre><code class="language-c++">it = v1.begin();//set v1 refer to the first
*it;//return value
it++;//point to the next
*it = 1234;//change value
it2 = it + 2;//send the address + 2 to another
</code></pre>
<h4>Stack: a LIFO(Last in First out) data structure</h4>
<p>Statement in C++:</p>
<pre><code class="language-c++">stack&lt;int&gt; stack_name;
</code></pre>
<p>Basic operations:</p>
<pre><code class="language-c++">stack_name.push(data);//push a data into the stack
cout&lt;&lt;stack_name.top();//read the data at top
stack_name.pop();//pop out the data at top
</code></pre>
<h4>Queue: a FIFO(First in First out) data structure</h4>
<p>Statement in C++:</p>
<pre><code class="language-c++">queue&lt;int&gt; q;
</code></pre>
<p>Basic operations:</p>
<pre><code class="language-c++">q.front();//read the data at the front
q.push();//push a data at the end of the queue
q.pop();//pop out the data at the front
q = queue&lt;int&gt;();//empty the queue
</code></pre>
<p>Then, let&#x27;s see a sample of using queue.</p>
<p>Cruel torture (AHU77)</p>
<hr/>
<p>Please read the question at <a href="oj.bofc.tech">bofcOJ</a></p>
<hr/>
<p>Code:</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main()
{
    int qty_children = 0, k;
    cin &gt;&gt; qty_children &gt;&gt; k;

    
    int sum = 0;
    queue&lt;int&gt; children;
    for (int i = 1; i &lt;= qty_children; i++)
    {
        children.push(i);
    } //statement queue
    while (sum &lt; qty_children-1)
    {

        for (int i = 0; i &lt; k-1; i++)
        {
            children.push(children.front());//if we do not pull out the line, thus we let this wild kid get to the back.
            children.pop();
        }
        children.pop();//when it comes to pull out the line, this wild kid is over.
        sum++;
    }
    cout &lt;&lt; children.front();

    return 0;
}
</code></pre>
<h4>Using dynamic array with pointer</h4>
<p>Code demo:</p>
<pre><code class="language-c++">int *p = new int[10];//Create an array when running.
delete[] p;//the realease of a dynamic array method is not same with a variable
</code></pre>
<h4>bitset</h4>
<p>A data structure which storages bit.</p>
<pre><code class="language-c++">    bitset&lt;4&gt; bitset1;//construct without parameter:set space 4

    bitset&lt;8&gt; bitset2(12);//the space is 8, storge 12 into binary system,use 0 to fill the blank bit.

    string s = &quot;100101&quot;;
    bitset&lt;10&gt; bitset3(s);//the space is 10,use 0 to fill the blank bit,the string CAN ONLY CONTAINS 0 and 1.
    
    char s2[] = &quot;10101&quot;;
    bitset&lt;13&gt; bitset4(s2);//the space is 13,use 0 to fill the blank bit

    cout &lt;&lt; bitset1 &lt;&lt; endl;//0000
    cout &lt;&lt; bitset2 &lt;&lt; endl;//00001100
    cout &lt;&lt; bitset3 &lt;&lt; endl;//0000100101
    cout &lt;&lt; bitset4 &lt;&lt; endl;//0000000010101
    bitset3[0];//Simular as array,use subscript to access the elements.
    
</code></pre>
<p>There&#x27;s so many ways to use bitset, but let&#x27;s see struct first.</p>
<h4>Struct</h4>
<p>A struct is a data structure which contains serval variable type. The struct can also form an array!</p>
<p>C++ examples</p>
<pre><code class="language-c++">struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book = {&quot;C Language&quot;, &quot;RUNOOB&quot;, &quot;Programing Language&quot;, 123456};//define a struct and initialize


</code></pre>
<p>//Of course, you can use it as below: No initialize.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

struct student //define the struct of single student
{
    int number;
    int score;
};

int main()
{
	student students[10000];
       for (int i = 0; i &lt; total; i++) //input scores
      {
        cin &gt;&gt; students[i].number &gt;&gt; students[i].score;//See the examples here!
      }

    return 0;

}
//It means you can only define a struct and use it as a data type!
</code></pre>
<h5>Struct pointer</h5>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

struct student //define the struct of single student
{
    int number;
    int score;
};

int main()
{
    struct student students[100];

    scanf(&quot;%d%d&quot;, &amp;students[0].number, &amp;students[0].score); //See the examples here!

    struct student *p = students; //initialize the pointer.
    printf(&quot;%d&quot;, p-&gt;number);      
    p++;                          //go to next student.
    return 0;
}

</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

struct student
{
    int id;
    int maths;
};

int main()
{
    struct student stu1[2];
    struct student *p ;
    p=stu1;
    
    printf(&quot;%d&quot;,p-&gt;id);

    return 0;
}
</code></pre>
<h4>Vector</h4>
<p>This is a significant data structure in  C++ standard library , equals an array that can change memory size at will,and you can also CRUD in it in will.</p>
<p>Basic operations:</p>
<pre><code class="language-c++">vector&lt;int&gt; c;
c.push_back(1);//place the element at the end of the vector.

</code></pre>
<pre><code class="language-c++">vector&lt;Sales_item&gt; sales_vec;//vector can also store class or struct
vector&lt;vector&lt;string&gt;&gt;;//the elements in this vector are also vector objects.
</code></pre>
<p>Other operations:</p>
<pre><code class="language-c++">vector&lt;T&gt; v1{1,2,3,4,5};
vector&lt;T&gt; v2(5,5);//{5,5,5,5,5}
vector&lt;string&gt; v3={&quot;Hello&quot;,&quot;World&quot;,&quot;!&quot;};
vector&lt;int&gt; v4(10); //Create a vector have 10 elements, initialized by 0.
v4.push_back(1);//put an elemnet to the back of the vector;
v4.size();
</code></pre>
<p>Use array to initialize a vector</p>
<pre><code class="language-c++">int a[]={1,2,3,4,5};
vector&lt;int&gt; v1(begin(a),end(arr));//send the begin and end to construct.
</code></pre>
<h4>String</h4>
<p>String is a <strong>char</strong> sequence whose size is changeable .</p>
<p>Initialize:</p>
<pre><code class="language-c++">string s1;//an empty string has been created
string s2(10,&#x27;c&#x27;);//&quot;cccccccccc&quot;
</code></pre>
<p>Operations:</p>
<p>| Operation | Action                          |
| --------- | ------------------------------- |
| os&lt;&lt;s;    | Write s to ostream              |
| is&gt;&gt;s;    | Write instream to s             |
| s.size(); | Return the length;              |
| s1+s2     | Connect two strings             |
| s1&gt;=s2    | compare, use <em>dictionary order</em> |</p>
<p><strong>Get line</strong></p>
<pre><code class="language-c++">while(getline(cin,line)&amp;&amp;line.size()&gt;0)
{
    //code
}
</code></pre>
<p><strong>Character type:</strong></p>
<pre><code class="language-c++">tolower(c);//change into lower size
toupper(c);//change into upper size
</code></pre>
<p><code>Warning</code>: Do not do this:</p>
<pre><code class="language-c++">char a[]=&quot;fff&quot;;
char b[]=&quot;aaa&quot;;
string c = a+b;//ERROR: you are trying to add two pointers!!!
</code></pre>
<h4>Set</h4>
<p>An example:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main()
{
    int case_number;
    cin &gt;&gt; case_number; //Input the amount
    set&lt;int&gt; numbers;
    int put_number;
    set&lt;int&gt; :: iterator out_number;
    for (int i = 0; i &lt; case_number; i++) // Input data
    {
        cin &gt;&gt; put_number;
        numbers.insert(put_number);
    }
    cout &lt;&lt; numbers.size() &lt;&lt; endl;
    int count=0;
    for (out_number = numbers.begin(); out_number != numbers.end(); out_number++) 
    {
        
        cout &lt;&lt; *out_number ;
        count++;
        if(count &lt;= numbers.size()-1) cout&lt;&lt;&quot; &quot;;
    }

    return 0;
}
</code></pre>
<p>Set can automatically sort, and the elements are strictly diverse .</p>
<h4>优先队列:优先级最高的元素先出的队列</h4>
<p>C++的标准库中包含了一个很好用的数据结构:优先队列.该结构可以将优先级大的元素排到前面.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main()
{
	priority_queue&lt;int&gt; que_apples; //默认使用vector,大的数字优先
	priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; app_que;//小的数字优先
	
	return 0;
}
</code></pre>
<p>自定义优先级:重载运算符</p>
<pre><code class="language-c++">class Student
{
    int id;
    char name[20];
    bool gender;
    bool operator &lt; (Student &amp;a) const
    {
        return id &gt; a.id;
    }
};
</code></pre>
<h2>STL算法</h2>
<h4>快排(sort),包含在algorithm</h4>
<p>这个算法极其牛逼,解放了万千程序员的双手(赞美)!!!</p>
<p>快排作用的内容:数组/向量容器等</p>
<p>C++使用实例</p>
<pre><code class="language-c++">vector&lt;int&gt; v1;
int numbers[2][5];
struct student
{
    int number;
    int score;
    string name;
}
//此处省略若干行插入数据代码,让我们假设这这里面有很多数据
sort(v1.begin(),v1.end());//默认从小到大排列
bool compare(int a , int b)//按某种排序方案排序
{
    return a&gt;b;//这样是降序排列
    return numbers[a][0]&gt;numbers[b][0];//还能读取某些数据的元素排列
    return student[a].score&gt;student[b].score;//还能读取某些结构体的成员
}
</code></pre>
<h2>常用基础算法(一些很基本的,要背的)</h2>
<h4>公因数公倍数</h4>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main()
{
    int m, n;
    int s = 0;
    int min = 0;
    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
    //最大公约数
    if (m &gt; n)
    {
        s = m;
        min = n;
    }
    else
    {
        s = n;
        min = m;
    }
    while (min != 0)
    {
        int t = s%min;
        s = min;
        min = t;
    }
    printf(&quot;%d\n&quot;,s);
    //重置两个数
    if (m &gt; n)
    {
        s = m;
        min = n;
    }
    else
    {
        s = n;
        min = m;
    }
    //公倍数
    for (int i = min;; i += min)
    {
        double resR = (double)i / s;
        int floor = i / s;

        if ((double)floor == resR)
        {
            printf(&quot;%d\n&quot;, i);
            break;
        }
    }

    return 0;
}
</code></pre>
<h4>筛法判断质数</h4>
<p>上代码:</p>
<pre><code class="language-c++">bool isPrime(int a)
{
    if (a == 2)
        return true;
    if (a % 2 == 0)
        return false;
    int x = sqrt(a);
    for (int i = 2; i &lt;= x; ++i)
    {
        if (a % i == 0)
            return false;
    }
    return true;
}
</code></pre>
<h4>素数的埃式筛法</h4>
<p>先确认一个数是素数,然后划掉其倍数,在找到下一个素数后,再划掉其倍数,最后只剩素数.</p>
<pre><code class="language-c++">int main()
{
    int number_list[1000] = {0}; //we can get primes below 1000
    bool break_flag = false;
    number_list[0] = 1;
    int pri = 2;
    while (!break_flag)
    {
        // the non-prime will be mark 1
        int count = pri;
        while (count &lt;= 1000)
        {
            count += pri;
            if (count &gt;= 1000)
                break;
            number_list[count] = 1;
        }
        int temp_pri = pri;
        while (true)
        {
            temp_pri++;
            if (temp_pri &gt;= 999)
            {
                break_flag = true;
                break;
            }
            if (number_list[temp_pri] == 0)
            {
                pri = temp_pri;
                break;
            }
        }
    }
    for (int i = 0; i &lt; 1000; i++)
    {
        if (number_list[i] == 0)
        {
            cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        }
    }

    return 0;
}
</code></pre>
<h4>分解质因数(简便方法)</h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
//这个程序适合好好阅读并分析
void foo(long long int n)
{
    long long int sqr = sqrt(n);//测试质数只需测到平方的取整
    long long int i = 0;
    for(i = 2; i &lt;= sqr; i++)//从2开始测
    {
        if(n % i == 0 &amp;&amp; (n /= i))//后面的表达式指的是除i留下剩余部分
        {
            printf(&quot;%lld &quot;, i--);
        }
    }
    if(n != 1)//不打印1作为因子
    {
        printf(&quot;%lld&quot;, n);
    }
    printf(&quot;\n&quot;);
}

int main()
{
    long long int n ;
    scanf(&quot;%lld&quot;, &amp;n);
    foo(n);
    return 0;
}

</code></pre>
<h4>查找字符(这是C标准库里的内容)</h4>
<p>用于在一个字符串(也就是char数组)中查找指定的字符</p>
<pre><code class="language-c++">strchr(string_name, &#x27;A&#x27;);//在string name 这个字符串中寻找A这个字符
//返回有多种可能,若找到,返回指向这个字符的指针,否则返回NULL(这个NULL是标识符,不是字符串之类的玩意)
</code></pre>
<h4>位运算</h4>
<p>位运算是一种直接操作位的运算,其包含多种运算符:</p>
<p>上代码:</p>
<pre><code class="language-c++">&lt;&lt;; //左移运算符,移动时丢弃左边的位,用0补充
&quot;11110000&quot;&lt;&lt;&quot;10000000&quot;;//左移了3位!!!
&gt;&gt;; //右移运算符,移动时丢弃右边的位,左边用0或原来丢弃的左边的位补充!!!
&quot;11111111&quot;&gt;&gt;&quot;00001111&quot;;//右移了四位!!!
    
//接下来看看逻辑位运算
~;//按位非,倒置0/1
|;//按位或,有一为1,否则为0
^;//XOR,相同为0,不同为1
&amp;;//AND,都为1才为1,否则为0

//一些常用的位逻辑运算:
lottabits |= pow(2,3);//打开位,也就是将某一位置为1,其中后面的2的多少次方代表着打开的位置(2的0次方代表右起第一位,以此类推)
lottabits ^= pow(2,3);//切换位:置反
lottabits &amp;= pow(2,3);//关闭位:置0
bool isOpen = lottabits &amp; pow(2,3);//测试某一位是否为1(打开),返回true or false.
</code></pre></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      \"C++语言学习笔记\"\r\nintro:   \"\"\r\ndate:       2019-11-19 16:00:00\r\nauthor:     \"Makinohara\"\r\nfeatured_image: http://msfasr.com//img/cpp.jpg\r\ncatalog: true\r\ntags:\r\n    - 编程语言\r\n---\r\n\r\n[TOC]\r\n\r\n\r\n\r\n\u003e I'm refactoring this note into English version. This may spend me lots of time.\r\n\u003e\r\n\u003e But I believe it will be a good form for me to learn English.\r\n\u003e\r\n\u003e Carry on! \r\n\r\n# C++ Language Studying(Section 1)\r\n\r\n## Basic C++ Knowledge\r\n\r\n### Some tiny knowledge points\r\n\r\n1B=8bit(B refers byte and b refers bit)\r\n\r\n## C++ I/O\r\n\r\n\r\n\r\n## C++ Sentences\r\n\r\n#### Range for\r\n\r\n```c++\r\nfor(auto s:str1)\r\n{\r\n    cout\u003c\u003cS\u003c\u003cendl;\r\n}\r\n```\r\n\r\nBy using range for, you can process each element in an array or a sequence .\r\n\r\n## C++ 类\r\n\r\n众所周知，支持面向对象编程是C++的一个重要特性，接下来我们来看类。\r\n\r\n```c++\r\nclass Box\r\n{\r\n   public:\r\n      double length;   // 盒子的长度\r\n      double breadth;  // 盒子的宽度\r\n      double height;   // 盒子的高度\r\n};\r\n```\r\n\r\n带成员函数声明和定义：\r\n\r\n```c++\r\nclass Box\r\n{\r\n   public:\r\n      double length;   // 长度\r\n      double breadth;  // 宽度\r\n      double height;   // 高度\r\n      // 成员函数声明\r\n      double get(void);\r\n      void set( double len, double bre, double hei );\r\n};\r\n// 成员函数定义\r\ndouble Box::get(void)\r\n{\r\n    return length * breadth * height;\r\n}\r\n \r\nvoid Box::set( double len, double bre, double hei)\r\n{\r\n    length = len;\r\n    breadth = bre;\r\n    height = hei;\r\n}\r\n```\r\n\r\n### 析构函数：\r\n\r\n```c++\r\nclass String{\r\nprivate:\r\n    char* p;\r\npublic:\r\n    String(int n);\r\n    ~String();\r\n};\r\nString::~String(){   //析构函数\r\n    delete[] p;\r\n}\r\nString::String(int n){\r\n    p = new char[n];\r\n}\r\n```\r\n\r\n\r\n\r\n### c++继承\r\n\r\n```c++\r\n// 基类\r\nclass Shape \r\n{\r\n   public:\r\n      void setWidth(int w)\r\n      {\r\n         width = w;\r\n      }\r\n      void setHeight(int h)\r\n      {\r\n         height = h;\r\n      }\r\n   protected:\r\n      int width;\r\n      int height;\r\n};\r\n \r\n// 派生类\r\nclass Rectangle: public Shape\r\n{\r\n   public:\r\n      int getArea()\r\n      { \r\n         return (width * height); \r\n      }\r\n};\r\n\r\n//多继承\r\nclass \u003c派生类名\u003e:\u003c继承方式1\u003e\u003c基类名1\u003e,\u003c继承方式2\u003e\u003c基类名2\u003e,…\r\n{\r\n\u003c派生类类体\u003e\r\n};\r\n```\r\n\r\n\r\n\r\n重载：\r\n\r\n```c++\r\n//运算符重载：\r\nBox operator+(const Box\u0026 b)\r\n      {\r\n         Box box;\r\n         box.length = this-\u003elength + b.length;\r\n         box.breadth = this-\u003ebreadth + b.breadth;\r\n         box.height = this-\u003eheight + b.height;\r\n         return box;\r\n      }\r\n\r\n//函数重载：\r\nclass printData\r\n{\r\n   public:\r\n      void print(int i) {\r\n        cout \u003c\u003c \"整数为: \" \u003c\u003c i \u003c\u003c endl;\r\n      }\r\n \r\n      void print(double  f) {\r\n        cout \u003c\u003c \"浮点数为: \" \u003c\u003c f \u003c\u003c endl;\r\n      }\r\n \r\n      void print(char c[]) {\r\n        cout \u003c\u003c \"字符串为: \" \u003c\u003c c \u003c\u003c endl;\r\n      }\r\n};\r\n```\r\n\r\n\r\n\r\n## 命名空间\r\n\r\n```c++\r\n// 第一个命名空间\r\nnamespace first_space{\r\n   void func(){\r\n      cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl;\r\n   }\r\n}\r\n// 第二个命名空间\r\nnamespace second_space{\r\n   void func(){\r\n      cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl;\r\n   }\r\n}\r\nint main ()\r\n{\r\n \r\n   // 调用第一个命名空间中的函数\r\n   first_space::func();\r\n   \r\n   // 调用第二个命名空间中的函数\r\n   second_space::func(); \r\n \r\n   return 0;\r\n}\r\n```\r\n\r\n## 王氏C++——应付考试内容\r\n\r\n```c++\r\n//自由函数与成员函数，运算符重载的不同\r\n\r\n#include\u003cbits/stdc++.h\u003e\r\nclass complex{\r\n    public:\r\n    complex(int ri = 0, int ii = 0){\r\n        r = ri;\r\n        i = ii;\r\n    }\r\n    int r;\r\n    int i;\r\n    friend complex operator+(const complex \u0026b) ;//友元函数\r\n    //complex operator+(const complex \u0026b) const;  成员函数\r\n};\r\n\r\ncomplex operator+(const complex \u0026a,const complex \u0026b) {\r\n    return complex(a.r+b.r,a.i+b.i);\r\n}\r\n\r\n/*\r\n成员函数\r\ncomplex complex::operator+(const complex \u0026b) const{\r\n    return complex(r+b.r,i+b.i);\r\n}\r\n*/\r\n\r\nint main(){\r\n    complex c1(1,1);\r\n    complex c2(2,2);\r\n    complex c3 = c1+c2;\r\n    complex c4 = c2+3;//成员函数无法执行此操作，而友元函数会得出结果c4.r = c2.r+3,c4.r = c2.r;\r\n    return 0;\r\n}\r\n\r\n//有关数组一说\r\nfloat[2] x[100];//这是每个元素为2个float元素为元素的数组的数组。但是是错的，编译不通过。\r\n```\r\n\r\n### 引用：\r\n\r\n```c++\r\nint x = 5;\r\nint \u0026rx = x;\r\n//rx = 7-\u003ex = 7\r\n```\r\n\r\n### 函数：\r\n\r\n```c++\r\ndatatype func_name(datatype a){\r\n\t\r\n}\r\n\r\ndatatype func_name(datatype \u0026rr){\r\n    rr = 2;\r\n}\r\n\r\ndatatype func_name(const float \u0026rr){\r\n    rr = 2;//ERROR\r\n}\r\n\r\n//example:\r\nint fun(int \u0026i){\r\n    i = 36;\r\n    return i;\r\n}\r\n\r\nint main(){\r\n    int i = 3;\r\n    int f = fun(i);\r\n    return 0;\r\n}\r\n\r\n//数组名做参数\r\nint calcsum(int x[],int size){\r\n    int sum;\r\n    for (int i = 0; i \u003c size; i++)\r\n    {\r\n        sum+=x[i];\r\n    }\r\n    return sum;\r\n}\r\n\r\nint main(){\r\n    int x[2]={1,2};\r\n    int sum = calcsum(x,2);\r\n    return 0;\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n### 有关类的四个基本函数\r\n\r\n```c++\r\nclass Clock{\r\n    private:\r\n    int a;\r\n    int b;\r\n    public:\r\n    clock(int a, int b);//构造函数\r\n    clock();//默认构造函数\r\n    clock(int i,int j){\r\n        a = i;\r\n        b = j;\r\n    }\r\n    \r\n    //初始化列表：\r\n    clock(int s, int i):a(s), b(i){};\r\n    \r\n    //析构函数\r\n    ~clock;\r\n    \r\n    //拷贝构造函数\r\n    clock(const clock \u0026c){\r\n        a = c.a;\r\n        b = c.b;\r\n    }\r\n    \r\n    //拷贝赋值函数\r\n    clock\u0026 operator=(const clock \u0026c){\r\n        if (\u0026c!= this){   //避免自己拷贝自己的情况\r\n            a = c.a;\r\n            b = c.b;\r\n        }\r\n        return *this;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n### 常函数：\r\n\r\n\r\n\r\n```c++\r\nclass circle{\r\n    private:\r\n    int r;\r\n    public:\r\n    int getR(){\r\n        return r;\r\n    }\r\n    circle(int i){\r\n        r = i;\r\n    }\r\n\r\n    float getArea() /*(const)*/{\r\n        return 3.1415926 *r*r;\r\n    }\r\n    float getAreaC() const){\r\n        return 3.1415926 *r*r;\r\n    }\r\n};\r\n\r\n\r\n\r\nint main(){\r\n    const circle c1(1);\r\n    float area = c1.getArea();//错误，不是常函数无法访问const修饰的对象\r\n    float area = c1.getAreaC();//正确\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n### 继承：\r\n\r\n```c++\r\nclass circle2:/*(private or protected or public)*/circle{\r\n    ......\r\n}\r\n```\r\n\r\n### 虚函数：\r\n\r\n```c++\r\n#include\u003ciostream\u003e\r\n\r\nclass Base1{\r\n\tpublic:\r\n    virtual void display() const;\r\n};\r\n\r\nvoid Base1::display() const{\r\n    std::cout\u003c\u003c1\u003c\u003cstd::endl;\r\n}\r\n\r\nclass Base2:public Base1{\r\n    public:\r\n    void display() const ;\r\n};\r\nvoid Base2::display() const{\r\n    std::cout\u003c\u003c2\u003c\u003cstd::endl;\r\n}\r\n\r\nvoid function(Base1 *ptr){//一个指向父类的指针\r\n    ptr-\u003edisplay();\r\n}\r\n\r\nint main(){\r\n    Base1 b1;\r\n    Base2 b2;\r\n    function(\u0026b1);//调用 void Base1::display() const\r\n    function(\u0026b2);//调用 void Base2::display() const\r\n}\r\n```\r\n\r\n三种继承方式：父类成员对子类的可见性：\r\n\r\n| 父类访问控制/继承方式： | public    | protected | private |\r\n| ----------------------- | --------- | --------- | ------- |\r\n| public                  | public    | protected | private |\r\n| protected               | protected | protected | private |\r\n| private                 | private   | private   | private |\r\n\r\n\r\n\r\n## C++ Variable\r\n\r\n#### C++ Variable types:\r\n\r\n| Type        | Implication                                   | size                 |\r\n| ----------- | --------------------------------------------- | -------------------- |\r\n| bool        | bool type                                     | undefined            |\r\n| char        | character                                     | 8b                   |\r\n| wchar_t     | wide character                                | 16b                  |\r\n| char16_t    | Unicode character                             | 16b                  |\r\n| char32_t    | Unicode character                             | 32b                  |\r\n| short       | short integer                                 | 16b                  |\r\n| int         | integer                                       | 16b                  |\r\n| long        | long integer                                  | 32b                  |\r\n| long long   | long long integer                             | 64b                  |\r\n| float       | single-precision floating point number        | 6 significant digit  |\r\n| double      | double-precision floating point number        | 10 significant digit |\r\n| long double | expand double-precision floating point number | 10 significant digit |\r\n\r\nUse `unsigned` to state an unsigned variable type, an unsigned variable do not have a sign digit.\r\n\r\n#### Type conversion\r\n\r\n```c++\r\nbool a =42;// 0 refers true and the others refer false.\r\nint i =3.14;// the value of i is 3,the fractional digit has been dropped.\r\ndouble pi =i;//the value of pi is 3\r\nunsigned char c = -1; //the value of c is 255\r\n```\r\n\r\n`WARNING`: **DO NOT USE UNSIGNED TYPE AND  SIGNED TYPE VARIABLE AT THE SAME TIME !!!**\r\n\r\n#### Reference\r\n\r\n```c++\r\nint a=3;\r\nint \u0026num = a;// num is a reference of a\r\nint \u0026num2;//ERROR: reference must be initialized\r\n```\r\n\r\n#### Pointer\r\n\r\nPointers point to a pointer:\r\n\r\n```c++\r\nint a=1024;\r\nint *ptr1 = \u0026a;\r\nint **ptr2 = \u0026ptr1;\r\ncout\u003c\u003c**ptr2\u003c\u003cendl;// output 1024\r\n```\r\n\r\nC++ Standard Library :: begin, end\r\n\r\n```c++\r\nint ia[]={1,2,3,4,5,6,7,8,9};\r\nint *beg = begin(ia);//refer a[0]\r\nint *end = end(ia);//refer the next position after the last element of an array\r\n```\r\n\r\nPointer with custom size:\r\n\r\n```c++\r\nint a[2][2];\r\nint *p[2];//NOT THIS: It created a pointer array\r\nint (*p2)[2];//a pointer which can point to an array with 2 ints.\r\n//use decltype or auto:\r\ndecltype *p3 = a;\r\n```\r\n\r\n\r\n\r\n#### Const\r\n\r\nYou can use `const` to make a variable unchangeable.\r\n\r\n**Top-level-const and Low-level-const:**\r\n\r\n```c++\r\nint i=0;\r\nint *const p1 = \u0026i;//the value of pointer can not be changed,top-level-const\r\nconst int ci =42;//the value of ci can not be changed.\r\nconst int *p2 = \u0026ci;//the value of pointer can not be changed\r\n```\r\n\r\n#### Typedef\r\n\r\n```c++\r\ntypedef double wages;\r\n```\r\n\r\n#### Decltype\r\n\r\nUse decltype to get a type that a function returns.\r\n\r\n```c++\r\ndecltype(f()) sum =0;//the type of sum is just the type that f() returns.\r\n```\r\n\r\n#### Write your own head file\r\n\r\nYou'd better define your struct and class in a head file .\r\n\r\n## Data Structure(STL)\r\n\r\n#### Using statement\r\n\r\nBefore using C++ Standard Library, you can:\r\n\r\n```c++\r\n//method 1\r\nstd::cout\u003c\u003c\"Test\"\u003c\u003cstd::endl;\r\n//method 2:\r\nusing namespace std;\r\ncout\u003c\u003c\"123\"\u003c\u003cendl;\r\n```\r\n\r\n\r\n\r\n#### Using iterator\r\n\r\nA sort of intelligence pointer , used for STD .\r\n\r\nC++ example:\r\n\r\n```c++\r\n#include \u003cbits/stdc++.h\u003e\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    vector\u003cint\u003e vec1;//Statement\r\n    for (int i = 0; i \u003c 5; i++)\r\n    {\r\n        vec1.push_back(i);\r\n    }\r\n    auto it = vec1.begin();//Auto Statement\r\n    vector\u003cint\u003e:: iterator it = vec1.begin();//Standard statement\r\n\r\n    cout \u003c\u003c *it \u003c\u003c endl;\r\n    for (; it != vec1.end(); it++)\r\n    {\r\n        cout \u003c\u003c *it \u003c\u003c endl;\r\n    }\r\n    \r\n    return 0;\r\n    \r\n}\r\n```\r\n\r\nOperations:\r\n\r\n```c++\r\nit = v1.begin();//set v1 refer to the first\r\n*it;//return value\r\nit++;//point to the next\r\n*it = 1234;//change value\r\nit2 = it + 2;//send the address + 2 to another\r\n```\r\n\r\n\r\n\r\n#### Stack: a LIFO(Last in First out) data structure\r\n\r\nStatement in C++:\r\n\r\n```c++\r\nstack\u003cint\u003e stack_name;\r\n```\r\n\r\nBasic operations:\r\n\r\n```c++\r\nstack_name.push(data);//push a data into the stack\r\ncout\u003c\u003cstack_name.top();//read the data at top\r\nstack_name.pop();//pop out the data at top\r\n```\r\n\r\n#### Queue: a FIFO(First in First out) data structure\r\n\r\nStatement in C++:\r\n\r\n```c++\r\nqueue\u003cint\u003e q;\r\n```\r\n\r\nBasic operations:\r\n\r\n```c++\r\nq.front();//read the data at the front\r\nq.push();//push a data at the end of the queue\r\nq.pop();//pop out the data at the front\r\nq = queue\u003cint\u003e();//empty the queue\r\n```\r\n\r\nThen, let's see a sample of using queue.\r\n\r\nCruel torture (AHU77)\r\n\r\n------\r\n\r\nPlease read the question at [bofcOJ](oj.bofc.tech)\r\n\r\n------\r\n\r\nCode:\r\n\r\n```c++\r\n#include \u003cbits/stdc++.h\u003e\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int qty_children = 0, k;\r\n    cin \u003e\u003e qty_children \u003e\u003e k;\r\n\r\n    \r\n    int sum = 0;\r\n    queue\u003cint\u003e children;\r\n    for (int i = 1; i \u003c= qty_children; i++)\r\n    {\r\n        children.push(i);\r\n    } //statement queue\r\n    while (sum \u003c qty_children-1)\r\n    {\r\n\r\n        for (int i = 0; i \u003c k-1; i++)\r\n        {\r\n            children.push(children.front());//if we do not pull out the line, thus we let this wild kid get to the back.\r\n            children.pop();\r\n        }\r\n        children.pop();//when it comes to pull out the line, this wild kid is over.\r\n        sum++;\r\n    }\r\n    cout \u003c\u003c children.front();\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n#### Using dynamic array with pointer\r\n\r\nCode demo:\r\n\r\n```c++\r\nint *p = new int[10];//Create an array when running.\r\ndelete[] p;//the realease of a dynamic array method is not same with a variable\r\n```\r\n\r\n#### bitset\r\n\r\nA data structure which storages bit.\r\n\r\n```c++\r\n    bitset\u003c4\u003e bitset1;//construct without parameter:set space 4\r\n\r\n    bitset\u003c8\u003e bitset2(12);//the space is 8, storge 12 into binary system,use 0 to fill the blank bit.\r\n\r\n    string s = \"100101\";\r\n    bitset\u003c10\u003e bitset3(s);//the space is 10,use 0 to fill the blank bit,the string CAN ONLY CONTAINS 0 and 1.\r\n    \r\n    char s2[] = \"10101\";\r\n    bitset\u003c13\u003e bitset4(s2);//the space is 13,use 0 to fill the blank bit\r\n\r\n    cout \u003c\u003c bitset1 \u003c\u003c endl;//0000\r\n    cout \u003c\u003c bitset2 \u003c\u003c endl;//00001100\r\n    cout \u003c\u003c bitset3 \u003c\u003c endl;//0000100101\r\n    cout \u003c\u003c bitset4 \u003c\u003c endl;//0000000010101\r\n    bitset3[0];//Simular as array,use subscript to access the elements.\r\n    \r\n```\r\n\r\nThere's so many ways to use bitset, but let's see struct first.\r\n\r\n#### Struct\r\n\r\nA struct is a data structure which contains serval variable type. The struct can also form an array!\r\n\r\nC++ examples\r\n\r\n```c++\r\nstruct Books\r\n{\r\n   char  title[50];\r\n   char  author[50];\r\n   char  subject[100];\r\n   int   book_id;\r\n} book = {\"C Language\", \"RUNOOB\", \"Programing Language\", 123456};//define a struct and initialize\r\n\r\n\r\n```\r\n\r\n//Of course, you can use it as below: No initialize.\r\n\r\n```c++\r\n#include \u003cbits/stdc++.h\u003e\r\n\r\nusing namespace std;\r\n\r\nstruct student //define the struct of single student\r\n{\r\n    int number;\r\n    int score;\r\n};\r\n\r\nint main()\r\n{\r\n\tstudent students[10000];\r\n       for (int i = 0; i \u003c total; i++) //input scores\r\n      {\r\n        cin \u003e\u003e students[i].number \u003e\u003e students[i].score;//See the examples here!\r\n      }\r\n\r\n    return 0;\r\n\r\n}\r\n//It means you can only define a struct and use it as a data type!\r\n```\r\n\r\n##### Struct pointer\r\n\r\n```c++\r\n#include \u003cstdio.h\u003e\r\n#include \u003cstring.h\u003e\r\n#include \u003cstdlib.h\u003e\r\n\r\nstruct student //define the struct of single student\r\n{\r\n    int number;\r\n    int score;\r\n};\r\n\r\nint main()\r\n{\r\n    struct student students[100];\r\n\r\n    scanf(\"%d%d\", \u0026students[0].number, \u0026students[0].score); //See the examples here!\r\n\r\n    struct student *p = students; //initialize the pointer.\r\n    printf(\"%d\", p-\u003enumber);      \r\n    p++;                          //go to next student.\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n```c\r\n#include \u003cstdio.h\u003e\r\n#include \u003cstring.h\u003e\r\n#include \u003cstdlib.h\u003e\r\n\r\nstruct student\r\n{\r\n    int id;\r\n    int maths;\r\n};\r\n\r\nint main()\r\n{\r\n    struct student stu1[2];\r\n    struct student *p ;\r\n    p=stu1;\r\n    \r\n    printf(\"%d\",p-\u003eid);\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n#### Vector\r\n\r\nThis is a significant data structure in  C++ standard library , equals an array that can change memory size at will,and you can also CRUD in it in will.\r\n\r\nBasic operations:\r\n\r\n```c++\r\nvector\u003cint\u003e c;\r\nc.push_back(1);//place the element at the end of the vector.\r\n\r\n```\r\n\r\n```c++\r\nvector\u003cSales_item\u003e sales_vec;//vector can also store class or struct\r\nvector\u003cvector\u003cstring\u003e\u003e;//the elements in this vector are also vector objects.\r\n```\r\n\r\nOther operations:\r\n\r\n```c++\r\nvector\u003cT\u003e v1{1,2,3,4,5};\r\nvector\u003cT\u003e v2(5,5);//{5,5,5,5,5}\r\nvector\u003cstring\u003e v3={\"Hello\",\"World\",\"!\"};\r\nvector\u003cint\u003e v4(10); //Create a vector have 10 elements, initialized by 0.\r\nv4.push_back(1);//put an elemnet to the back of the vector;\r\nv4.size();\r\n```\r\n\r\nUse array to initialize a vector \r\n\r\n```c++\r\nint a[]={1,2,3,4,5};\r\nvector\u003cint\u003e v1(begin(a),end(arr));//send the begin and end to construct.\r\n```\r\n\r\n\r\n\r\n#### String\r\n\r\nString is a **char** sequence whose size is changeable .\r\n\r\nInitialize:\r\n\r\n```c++\r\nstring s1;//an empty string has been created\r\nstring s2(10,'c');//\"cccccccccc\"\r\n```\r\n\r\nOperations:\r\n\r\n| Operation | Action                          |\r\n| --------- | ------------------------------- |\r\n| os\u003c\u003cs;    | Write s to ostream              |\r\n| is\u003e\u003es;    | Write instream to s             |\r\n| s.size(); | Return the length;              |\r\n| s1+s2     | Connect two strings             |\r\n| s1\u003e=s2    | compare, use *dictionary order* |\r\n\r\n**Get line**\r\n\r\n```c++\r\nwhile(getline(cin,line)\u0026\u0026line.size()\u003e0)\r\n{\r\n    //code\r\n}\r\n```\r\n\r\n**Character type:**\r\n\r\n```c++\r\ntolower(c);//change into lower size\r\ntoupper(c);//change into upper size\r\n```\r\n\r\n`Warning`: Do not do this:\r\n\r\n```c++\r\nchar a[]=\"fff\";\r\nchar b[]=\"aaa\";\r\nstring c = a+b;//ERROR: you are trying to add two pointers!!!\r\n```\r\n\r\n\r\n\r\n#### Set\r\n\r\nAn example:\r\n\r\n```c++\r\n#include \u003ciostream\u003e\r\n#include \u003cset\u003e\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int case_number;\r\n    cin \u003e\u003e case_number; //Input the amount\r\n    set\u003cint\u003e numbers;\r\n    int put_number;\r\n    set\u003cint\u003e :: iterator out_number;\r\n    for (int i = 0; i \u003c case_number; i++) // Input data\r\n    {\r\n        cin \u003e\u003e put_number;\r\n        numbers.insert(put_number);\r\n    }\r\n    cout \u003c\u003c numbers.size() \u003c\u003c endl;\r\n    int count=0;\r\n    for (out_number = numbers.begin(); out_number != numbers.end(); out_number++) \r\n    {\r\n        \r\n        cout \u003c\u003c *out_number ;\r\n        count++;\r\n        if(count \u003c= numbers.size()-1) cout\u003c\u003c\" \";\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nSet can automatically sort, and the elements are strictly diverse .\r\n\r\n#### 优先队列:优先级最高的元素先出的队列\r\n\r\nC++的标准库中包含了一个很好用的数据结构:优先队列.该结构可以将优先级大的元素排到前面.\r\n\r\n```c++\r\n#include \u003cbits/stdc++.h\u003e\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tpriority_queue\u003cint\u003e que_apples; //默认使用vector,大的数字优先\r\n\tpriority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e app_que;//小的数字优先\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n自定义优先级:重载运算符\r\n\r\n```c++\r\nclass Student\r\n{\r\n    int id;\r\n    char name[20];\r\n    bool gender;\r\n    bool operator \u003c (Student \u0026a) const\r\n    {\r\n        return id \u003e a.id;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## STL算法\r\n\r\n#### 快排(sort),包含在algorithm\r\n\r\n这个算法极其牛逼,解放了万千程序员的双手(赞美)!!!\r\n\r\n快排作用的内容:数组/向量容器等\r\n\r\nC++使用实例\r\n\r\n```c++\r\nvector\u003cint\u003e v1;\r\nint numbers[2][5];\r\nstruct student\r\n{\r\n    int number;\r\n    int score;\r\n    string name;\r\n}\r\n//此处省略若干行插入数据代码,让我们假设这这里面有很多数据\r\nsort(v1.begin(),v1.end());//默认从小到大排列\r\nbool compare(int a , int b)//按某种排序方案排序\r\n{\r\n    return a\u003eb;//这样是降序排列\r\n    return numbers[a][0]\u003enumbers[b][0];//还能读取某些数据的元素排列\r\n    return student[a].score\u003estudent[b].score;//还能读取某些结构体的成员\r\n}\r\n```\r\n\r\n\r\n\r\n## 常用基础算法(一些很基本的,要背的)\r\n\r\n#### 公因数公倍数\r\n\r\n```c++\r\n#include \u003cstdio.h\u003e\r\n#include \u003cmath.h\u003e\r\nint main()\r\n{\r\n    int m, n;\r\n    int s = 0;\r\n    int min = 0;\r\n    scanf(\"%d%d\", \u0026m, \u0026n);\r\n    //最大公约数\r\n    if (m \u003e n)\r\n    {\r\n        s = m;\r\n        min = n;\r\n    }\r\n    else\r\n    {\r\n        s = n;\r\n        min = m;\r\n    }\r\n    while (min != 0)\r\n    {\r\n        int t = s%min;\r\n        s = min;\r\n        min = t;\r\n    }\r\n    printf(\"%d\\n\",s);\r\n    //重置两个数\r\n    if (m \u003e n)\r\n    {\r\n        s = m;\r\n        min = n;\r\n    }\r\n    else\r\n    {\r\n        s = n;\r\n        min = m;\r\n    }\r\n    //公倍数\r\n    for (int i = min;; i += min)\r\n    {\r\n        double resR = (double)i / s;\r\n        int floor = i / s;\r\n\r\n        if ((double)floor == resR)\r\n        {\r\n            printf(\"%d\\n\", i);\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n#### 筛法判断质数\r\n\r\n上代码:\r\n\r\n```c++\r\nbool isPrime(int a)\r\n{\r\n    if (a == 2)\r\n        return true;\r\n    if (a % 2 == 0)\r\n        return false;\r\n    int x = sqrt(a);\r\n    for (int i = 2; i \u003c= x; ++i)\r\n    {\r\n        if (a % i == 0)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n```\r\n\r\n#### 素数的埃式筛法\r\n\r\n先确认一个数是素数,然后划掉其倍数,在找到下一个素数后,再划掉其倍数,最后只剩素数.\r\n\r\n```c++\r\nint main()\r\n{\r\n    int number_list[1000] = {0}; //we can get primes below 1000\r\n    bool break_flag = false;\r\n    number_list[0] = 1;\r\n    int pri = 2;\r\n    while (!break_flag)\r\n    {\r\n        // the non-prime will be mark 1\r\n        int count = pri;\r\n        while (count \u003c= 1000)\r\n        {\r\n            count += pri;\r\n            if (count \u003e= 1000)\r\n                break;\r\n            number_list[count] = 1;\r\n        }\r\n        int temp_pri = pri;\r\n        while (true)\r\n        {\r\n            temp_pri++;\r\n            if (temp_pri \u003e= 999)\r\n            {\r\n                break_flag = true;\r\n                break;\r\n            }\r\n            if (number_list[temp_pri] == 0)\r\n            {\r\n                pri = temp_pri;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i \u003c 1000; i++)\r\n    {\r\n        if (number_list[i] == 0)\r\n        {\r\n            cout \u003c\u003c i \u003c\u003c \" \";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 分解质因数(简便方法)\r\n\r\n```c\r\n#include \u003cstdio.h\u003e\r\n#include \u003cmath.h\u003e\r\n//这个程序适合好好阅读并分析\r\nvoid foo(long long int n)\r\n{\r\n    long long int sqr = sqrt(n);//测试质数只需测到平方的取整\r\n    long long int i = 0;\r\n    for(i = 2; i \u003c= sqr; i++)//从2开始测\r\n    {\r\n        if(n % i == 0 \u0026\u0026 (n /= i))//后面的表达式指的是除i留下剩余部分\r\n        {\r\n            printf(\"%lld \", i--);\r\n        }\r\n    }\r\n    if(n != 1)//不打印1作为因子\r\n    {\r\n        printf(\"%lld\", n);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    long long int n ;\r\n    scanf(\"%lld\", \u0026n);\r\n    foo(n);\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n#### 查找字符(这是C标准库里的内容)\r\n\r\n用于在一个字符串(也就是char数组)中查找指定的字符\r\n\r\n```c++\r\nstrchr(string_name, 'A');//在string name 这个字符串中寻找A这个字符\r\n//返回有多种可能,若找到,返回指向这个字符的指针,否则返回NULL(这个NULL是标识符,不是字符串之类的玩意)\r\n```\r\n\r\n#### 位运算\r\n\r\n位运算是一种直接操作位的运算,其包含多种运算符:\r\n\r\n上代码:\r\n\r\n```c++\r\n\u003c\u003c; //左移运算符,移动时丢弃左边的位,用0补充\r\n\"11110000\"\u003c\u003c\"10000000\";//左移了3位!!!\r\n\u003e\u003e; //右移运算符,移动时丢弃右边的位,左边用0或原来丢弃的左边的位补充!!!\r\n\"11111111\"\u003e\u003e\"00001111\";//右移了四位!!!\r\n    \r\n//接下来看看逻辑位运算\r\n~;//按位非,倒置0/1\r\n|;//按位或,有一为1,否则为0\r\n^;//XOR,相同为0,不同为1\r\n\u0026;//AND,都为1才为1,否则为0\r\n\r\n//一些常用的位逻辑运算:\r\nlottabits |= pow(2,3);//打开位,也就是将某一位置为1,其中后面的2的多少次方代表着打开的位置(2的0次方代表右起第一位,以此类推)\r\nlottabits ^= pow(2,3);//切换位:置反\r\nlottabits \u0026= pow(2,3);//关闭位:置0\r\nbool isOpen = lottabits \u0026 pow(2,3);//测试某一位是否为1(打开),返回true or false.\r\n```\r\n\r\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2019-11-19-Cpp.markdown"},"buildId":"ZF3YO57AemfjKbXhzWO3Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>