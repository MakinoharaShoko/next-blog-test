<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/876d048b5dab7c28.css" as="style"/><link rel="stylesheet" href="/_next/static/css/876d048b5dab7c28.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-f11614d8aa7ee555.js" defer=""></script><script src="/_next/static/chunks/pages/_app-bf55c49910772dbb.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/557-10798b428373902a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-a468c6c0f66f2931.js" defer=""></script><script src="/_next/static/HXrOUhiN06_k-DjdnFR0c/_buildManifest.js" defer=""></script><script src="/_next/static/HXrOUhiN06_k-DjdnFR0c/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><h1>计算机技术指标</h1>
<h2>CPU执行时间：</h2>
<p>$$Te = m/F$$</p>
<p>$$Te = m*T$$</p>
<p>m：CPU时钟周期数；T：时钟周期；F：频率</p>
<h2>CPI 每条指令平均时钟周期数：</h2>
<p>$$CPI = m/IC$$</p>
<p>$$CPI = \sum\limits_{i=1}^N (CPI_i*IC_i)/IC$$</p>
<p>IC：指令条数(总的)</p>
<h2>MIPS每秒百万条指令数：</h2>
<p>$$MIPS = IC/(Te*10^6)$$</p>
<p>$$MIPS = F/(CPI*10^6)$$</p>
<h1>存储系统</h1>
<h2>半导体容量扩展：</h2>
<p>1.线选法</p>
<p>用一根地址线选择一块芯片</p>
<p>2.全译码法</p>
<p>将全部地址线译码，地位直接用于片内寻址，高位用译码器译码后进行片选。（地址唯一、连续、没有地址重叠）</p>
<p>3.部分译码法：</p>
<p>将高位地址的部分地址线用于译码，部分不参与译码（所以可能会产生地址重叠，比如最高位为1和为0选择同一芯片，所以地址就重叠了）。</p>
<h3>拓展方式：</h3>
<p>1.位拓展方式</p>
<p>拓展每个字的位数</p>
<p>将芯片的地址线、片选信号和读写控制并联（视为一个芯片），然后将数据线分别连到各个芯片。</p>
<p>2.字拓展方式</p>
<p>拓展字数</p>
<p>将芯片的地址线、数据线和读写控制并联，然后将片选信号连到各个芯片。</p>
<p>3.字位拓展方式</p>
<p>同时拓展字数和位数</p>
<p>将所有芯片的读写控制线连到一起</p>
<p>将同一区域（位扩展）的芯片片选信号连到一起，不同区域的片选信号分开</p>
<p>将同一区域中不同芯片的数据线分别连接到应有的位置上</p>
<h2>Cache：</h2>
<p>读：</p>
<p>CPU发出读请求后，先由Cache控制器判断请求的字是否在Cache中，若命中，则对Cache读，否则从主存读所需字送CPU，并把该字所在块送Cache，如果Cache已满，则调用替换算法。</p>
<p>写：</p>
<p>1、写直达：</p>
<p>在写数据时既写入主存又写入Cache。</p>
<p>2、写回法：</p>
<p>在写入数据时先写入Cache，直到该块被替换时才写入主存。每个块需要设置一个“修改位”来判断是否要将这个块存回主存原来位置。</p>
<h3>Cache主存地址映像与变换</h3>
<p>1.全相连映像：</p>
<p>将主存中的块映射到Cache中的任意一块，使用相联存储器按内容寻址。</p>
<pre><code>主存:   主存块号+块内地址
          ↓      ↓
查不到  ←相连比较   ↓
         ↓       ↓
        查到      ↓
         ↓       ↓
Cache: Cache块号+块内地址
</code></pre>
<p>2.直接映像：</p>
<p>将主存映射到Cache中的一个固定块位置</p>
<p>$$i = j mod C $$</p>
<p>$$i = j mod 2^c$$</p>
<p>i:Cache块号；j:主存块号 C:块数 c：Cache位数</p>
<pre><code>主存：主存字块标记(t位)+Cache字块地址(c位)+块内地址(b位)
Cache：块号(c位)+块内地址(b位)
其中，在主存通过Cache字块地址找到对应到Cache中哪一块后，
再通过标记表的t位标记是否和主存字块t位标记相等判断是否命中。
</code></pre>
<p>3.组相连映像：</p>
<p>先把Cache分为Q组，每组R块</p>
<p>$$k = j\ mod\ Q$$</p>
<p>k:Cache组号；j:主存块号</p>
<p>块号为j的主存块影响到Cache中的块号为：</p>
<p>$$i = k*2^r+h$$</p>
<p>$$2^r$$:组内块号。r= 1, 每组2块；h:组内偏移，这个值是随机的，由于主存的一块会映射到Cache某组的任意一块。</p>
<p>r=0:每组1块，此时直接映像；r=c:每组$$2^c$$块，也就是只分一组，此时组内块号就是块号（Cache块号与主存块号），此时为全相连映像。</p>
<pre><code>主存:主存字块标记(t+r)+组号(c-r)+块内地址(b)
         ↓         ↓            ↓ 
      相联比较↘     ↓            ↓
         ←←←←←←←←←←←            ↓             
         ↓       ↘              ↓ 
Cache:组号(c-r)+组内块号(r)+块内地址(b)

备注：r越大，组越少，r=c，全是主存字块标记，此时全相连;
r=0，组号为c，此时组号等同于块号(每组只有一块)，而主存的t位标记仍然通过标记表的t位比较是否相等，相等则命中。
</code></pre>
<pre><code>在此种模式中，每组有一个相连比较表（只有一组就只有一个，即全相连），
首先先得出是哪一组的相连比较表，用主存标记t位相连比较，如相等，则得出组内块号，命中，如不相等，失效。

主要思想：分组进行组内的全相连，c=0就是只分一组，也就是正统的全相连。
</code></pre>
<h1>指令系统</h1>
<p>1、指令根据操作码数目分为零地址、一地址、二地址、三地址指令等。</p>
<h2>指令系统设计</h2>
<p>固定长编码：所有操作码的长度都是相等的。</p>
<p>Huffman编码：根据指令的出现概率编码，概率大的长，概率小的短。</p>
<p>编码过程：按出现概率自左向右排序，然后抽出概率最低的两个形成一个树，根节点是两者之和。然后重复，直到根节点概率为1。</p>
<p>指令由Huffman树确定，左边的子节点为0，右边为1，以此类推。</p>
<h3>扩展编码：</h3>
<p>a/b(m-n)扩展编码：a、b是有相同长度的编码数目，m、n是码长。</p>
<p>比如2/7、2-4代表的是同一种编码。</p>
<p>其中，比较短的编码的全1（比如：1111）一般用于作为前缀，代表切换至更长长度的编码。</p>
<p>算编码数：以编码为3-6-9-扩展编码为例</p>
<p>$$S_9 = ((2^3-S_3)\cdot2^{6-3}-S_6)\cdot2^{9-6}$$</p>
<p>其中，Sn代表码长为n的编码数目。</p>
<p>解释：$$2^3-S_3$$ 表示了在表示完码长为3的编码后，剩余的前缀数目。这些前缀可以用来拓展到6位。如果剩余的前缀越多，可以拓展出的组也就越多，然后再乘以每组可以表示的6码长编码数目（由于前3位是前缀，实际上只有$$2^{6-3}$$种结果），得到一共可以表示多少码长为6编码，再减去实际的，得到前缀数，以此类推，得到码长为9的编码可以表示的数目。</p>
<h1>控制器</h1>
<h2>控制器基础</h2>
<h3>控制器组成</h3>
<p>程序计数器PC：存指令的地址</p>
<p>指令寄存器IR：保存指令的内容</p>
<p>指令译码器ID：分析识别是怎样的指令</p>
<p>地址形成部件：根据不同的寻址方式形成操作数的有效地址。</p>
<p>脉冲源：作为时钟脉冲</p>
<p>启停线路：计算机启动信号，启动后时钟脉冲才能进入，然后启动节拍信号发生器开始工作。</p>
<p>节拍信号发生器：将脉冲转换为各个设备所需要的节拍信号</p>
<p>控制单元：将指令发出的各种控制信号按节拍分配。</p>
<p>中断控制逻辑：控制中断。</p>
<h3>寄存器：</h3>
<p>通用+PC+IR+AR（记录主存单元地址）+DR（数据缓冲寄存器，在CPU和主存间形成缓冲）+PSW（记录各种条件码，比如进位）</p>
<h2>微程序控制</h2>
<h3>关于容量：</h3>
<p>CS容量：$$2^{N_{AR}} \cdot N_{IR} $$，前者代表多少指令，后者代表每条指令多少位</p>
<p>IR位数：微程序位数，否则放不下</p>
<p>AR位数：下址位数</p>
<h3>微指令编码方式：</h3>
<p>直接控制法：每一位代表一个微命令</p>
<p>字段直接编译法：</p>
<p>1、微命令数=$$2^n-1$$，因000要代表不发出微命令。</p>
<p>2、每个互斥类可能有多个编码，但是互斥类之间是平行排布的，平铺在控制字段。下址字段则是固定的，存下条指令地址。</p>
<p>例如：</p>
<pre><code>组1|组2|组3|......|判别码|下址|
每个组是一个互斥类，代表2^n-1个指令。
</code></pre>
<h3>微指令执行方式：</h3>
<p>串行方式：在一条微指令执行完毕后才会执行下一条</p>
<p>并行方式：在一条微指令执行时，就取下一条微指令</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      \"计算机组成复习\"\r\nintro:   \"\"\r\ndate:       2021-7-9 21:00:01\r\nauthor:     \"Makinohara\"\r\ncatalog: true\r\ntags:\r\n    - 计算机基础\r\n    \r\n---\r\n\r\n# 计算机技术指标\r\n\r\n## CPU执行时间：\r\n\r\n$$Te = m/F$$\r\n\r\n$$Te = m*T$$\r\n\r\nm：CPU时钟周期数；T：时钟周期；F：频率\r\n\r\n## CPI 每条指令平均时钟周期数：\r\n\r\n$$CPI = m/IC$$\r\n\r\n$$CPI = \\sum\\limits_{i=1}^N (CPI_i*IC_i)/IC$$\r\n\r\nIC：指令条数(总的)\r\n\r\n## MIPS每秒百万条指令数：\r\n\r\n$$MIPS = IC/(Te*10^6)$$\r\n\r\n$$MIPS = F/(CPI*10^6)$$\r\n\r\n# 存储系统\r\n\r\n## 半导体容量扩展：\r\n\r\n1.线选法\r\n\r\n用一根地址线选择一块芯片\r\n\r\n2.全译码法\r\n\r\n将全部地址线译码，地位直接用于片内寻址，高位用译码器译码后进行片选。（地址唯一、连续、没有地址重叠）\r\n\r\n3.部分译码法：\r\n\r\n将高位地址的部分地址线用于译码，部分不参与译码（所以可能会产生地址重叠，比如最高位为1和为0选择同一芯片，所以地址就重叠了）。\r\n\r\n### 拓展方式：\r\n\r\n1.位拓展方式\r\n\r\n拓展每个字的位数\r\n\r\n将芯片的地址线、片选信号和读写控制并联（视为一个芯片），然后将数据线分别连到各个芯片。\r\n\r\n2.字拓展方式\r\n\r\n拓展字数\r\n\r\n将芯片的地址线、数据线和读写控制并联，然后将片选信号连到各个芯片。\r\n\r\n3.字位拓展方式\r\n\r\n同时拓展字数和位数\r\n\r\n将所有芯片的读写控制线连到一起\r\n\r\n将同一区域（位扩展）的芯片片选信号连到一起，不同区域的片选信号分开\r\n\r\n将同一区域中不同芯片的数据线分别连接到应有的位置上\r\n\r\n## Cache：\r\n\r\n读：\r\n\r\nCPU发出读请求后，先由Cache控制器判断请求的字是否在Cache中，若命中，则对Cache读，否则从主存读所需字送CPU，并把该字所在块送Cache，如果Cache已满，则调用替换算法。\r\n\r\n写：\r\n\r\n1、写直达：\r\n\r\n在写数据时既写入主存又写入Cache。\r\n\r\n2、写回法：\r\n\r\n在写入数据时先写入Cache，直到该块被替换时才写入主存。每个块需要设置一个“修改位”来判断是否要将这个块存回主存原来位置。\r\n\r\n### Cache主存地址映像与变换\r\n\r\n1.全相连映像：\r\n\r\n将主存中的块映射到Cache中的任意一块，使用相联存储器按内容寻址。\r\n\r\n```\r\n主存:   主存块号+块内地址\r\n          ↓      ↓\r\n查不到  ←相连比较   ↓\r\n         ↓       ↓\r\n        查到      ↓\r\n         ↓       ↓\r\nCache: Cache块号+块内地址\r\n```\r\n\r\n2.直接映像：\r\n\r\n将主存映射到Cache中的一个固定块位置\r\n\r\n$$i = j mod C $$\r\n\r\n$$i = j mod 2^c$$\r\n\r\ni:Cache块号；j:主存块号 C:块数 c：Cache位数\r\n\r\n```\r\n主存：主存字块标记(t位)+Cache字块地址(c位)+块内地址(b位)\r\nCache：块号(c位)+块内地址(b位)\r\n其中，在主存通过Cache字块地址找到对应到Cache中哪一块后，\r\n再通过标记表的t位标记是否和主存字块t位标记相等判断是否命中。\r\n```\r\n\r\n3.组相连映像：\r\n\r\n先把Cache分为Q组，每组R块\r\n\r\n$$k = j\\ mod\\ Q$$\r\n\r\nk:Cache组号；j:主存块号\r\n\r\n块号为j的主存块影响到Cache中的块号为：\r\n\r\n$$i = k*2^r+h$$\r\n\r\n$$2^r$$:组内块号。r= 1, 每组2块；h:组内偏移，这个值是随机的，由于主存的一块会映射到Cache某组的任意一块。\r\n\r\nr=0:每组1块，此时直接映像；r=c:每组$$2^c$$块，也就是只分一组，此时组内块号就是块号（Cache块号与主存块号），此时为全相连映像。\r\n\r\n```\r\n主存:主存字块标记(t+r)+组号(c-r)+块内地址(b)\r\n         ↓         ↓            ↓ \r\n      相联比较↘     ↓            ↓\r\n         ←←←←←←←←←←←            ↓             \r\n         ↓       ↘              ↓ \r\nCache:组号(c-r)+组内块号(r)+块内地址(b)\r\n\r\n备注：r越大，组越少，r=c，全是主存字块标记，此时全相连;\r\nr=0，组号为c，此时组号等同于块号(每组只有一块)，而主存的t位标记仍然通过标记表的t位比较是否相等，相等则命中。\r\n```\r\n\r\n```\r\n在此种模式中，每组有一个相连比较表（只有一组就只有一个，即全相连），\r\n首先先得出是哪一组的相连比较表，用主存标记t位相连比较，如相等，则得出组内块号，命中，如不相等，失效。\r\n\r\n主要思想：分组进行组内的全相连，c=0就是只分一组，也就是正统的全相连。\r\n```\r\n\r\n# 指令系统\r\n\r\n1、指令根据操作码数目分为零地址、一地址、二地址、三地址指令等。\r\n\r\n## 指令系统设计\r\n\r\n固定长编码：所有操作码的长度都是相等的。\r\n\r\nHuffman编码：根据指令的出现概率编码，概率大的长，概率小的短。\r\n\r\n编码过程：按出现概率自左向右排序，然后抽出概率最低的两个形成一个树，根节点是两者之和。然后重复，直到根节点概率为1。\r\n\r\n指令由Huffman树确定，左边的子节点为0，右边为1，以此类推。\r\n\r\n### 扩展编码：\r\n\r\na/b(m-n)扩展编码：a、b是有相同长度的编码数目，m、n是码长。\r\n\r\n比如2/7、2-4代表的是同一种编码。\r\n\r\n其中，比较短的编码的全1（比如：1111）一般用于作为前缀，代表切换至更长长度的编码。\r\n\r\n算编码数：以编码为3-6-9-扩展编码为例\r\n\r\n$$S_9 = ((2^3-S_3)\\cdot2^{6-3}-S_6)\\cdot2^{9-6}$$\r\n\r\n其中，Sn代表码长为n的编码数目。\r\n\r\n解释：$$2^3-S_3$$ 表示了在表示完码长为3的编码后，剩余的前缀数目。这些前缀可以用来拓展到6位。如果剩余的前缀越多，可以拓展出的组也就越多，然后再乘以每组可以表示的6码长编码数目（由于前3位是前缀，实际上只有$$2^{6-3}$$种结果），得到一共可以表示多少码长为6编码，再减去实际的，得到前缀数，以此类推，得到码长为9的编码可以表示的数目。\r\n\r\n# 控制器\r\n\r\n## 控制器基础\r\n\r\n### 控制器组成\r\n\r\n程序计数器PC：存指令的地址\r\n\r\n指令寄存器IR：保存指令的内容\r\n\r\n指令译码器ID：分析识别是怎样的指令\r\n\r\n地址形成部件：根据不同的寻址方式形成操作数的有效地址。\r\n\r\n脉冲源：作为时钟脉冲\r\n\r\n启停线路：计算机启动信号，启动后时钟脉冲才能进入，然后启动节拍信号发生器开始工作。\r\n\r\n节拍信号发生器：将脉冲转换为各个设备所需要的节拍信号\r\n\r\n控制单元：将指令发出的各种控制信号按节拍分配。\r\n\r\n中断控制逻辑：控制中断。\r\n\r\n### 寄存器：\r\n\r\n通用+PC+IR+AR（记录主存单元地址）+DR（数据缓冲寄存器，在CPU和主存间形成缓冲）+PSW（记录各种条件码，比如进位）\r\n\r\n## 微程序控制\r\n\r\n### 关于容量：\r\n\r\nCS容量：$$2^{N_{AR}} \\cdot N_{IR} $$，前者代表多少指令，后者代表每条指令多少位\r\n\r\nIR位数：微程序位数，否则放不下\r\n\r\nAR位数：下址位数\r\n\r\n### 微指令编码方式：\r\n\r\n直接控制法：每一位代表一个微命令\r\n\r\n字段直接编译法：\r\n\r\n1、微命令数=$$2^n-1$$，因000要代表不发出微命令。\r\n\r\n2、每个互斥类可能有多个编码，但是互斥类之间是平行排布的，平铺在控制字段。下址字段则是固定的，存下条指令地址。\r\n\r\n例如：\r\n\r\n```\r\n组1|组2|组3|......|判别码|下址|\r\n每个组是一个互斥类，代表2^n-1个指令。\r\n```\r\n\r\n### 微指令执行方式：\r\n\r\n串行方式：在一条微指令执行完毕后才会执行下一条\r\n\r\n并行方式：在一条微指令执行时，就取下一条微指令\r\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2021-7-9-计算机组成复习.markdown"},"buildId":"HXrOUhiN06_k-DjdnFR0c","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>