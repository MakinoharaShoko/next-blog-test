<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/876d048b5dab7c28.css" as="style"/><link rel="stylesheet" href="/_next/static/css/876d048b5dab7c28.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-f11614d8aa7ee555.js" defer=""></script><script src="/_next/static/chunks/pages/_app-bf55c49910772dbb.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/557-10798b428373902a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-a468c6c0f66f2931.js" defer=""></script><script src="/_next/static/ZF3YO57AemfjKbXhzWO3Q/_buildManifest.js" defer=""></script><script src="/_next/static/ZF3YO57AemfjKbXhzWO3Q/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><h2>WASM + Rust + WebWorker 实现高性能计算器</h2>
<p>假设我们现在需要执行一个 CPU 负载很大的运算。为了不阻塞主线程，我们希望用 Web Worker 将其放到一个新的线程中进行运算，这样就可以避免阻塞主线程。</p>
<p>而为了提高这个运算的性能，我们希望用 Rust 编写的 WASM 程序来运算。</p>
<p><strong>本文就将实现在 Web Worker 中调用 WASM 进行运算。</strong></p>
<p>首先，我们来编写一段 Rust 代码，用于完成实际的计算。</p>
<pre><code class="language-rust">extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern &quot;C&quot; {}

#[wasm_bindgen]
pub fn wasm_add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>然后，将其编译为 WASM ，具体的方法参见我的上一篇博文。</p>
<p>接下来，我们需要创建一个网页，用于测试我们的函数。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;TestWoker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;module&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 <code>script.js</code>里面，我们要创建一个 Web Worker。</p>
<pre><code class="language-js">if (window.Worker) {
    //加载worker，注意第二个参数要有，否则无法导入 module
    const myWorker = new Worker(&#x27;./worker.js&#x27;, {type: &#x27;module&#x27;});
    myWorker.postMessage([1, 2]);//发送消息
    myWorker.postMessage([3, 4]);//发送消息
    setTimeout(() =&gt; {
        myWorker.postMessage([7, 8])
    }, 1000); //1秒后发送消息，用于在编译完成后使 worker 收到消息。
    myWorker.onmessage = (m) =&gt; {
        const data = m.data;
        console.log(&#x27;data from wasm: &#x27; + data); //拿到 wasm 计算的结果
    }
}
</code></pre>
<p>然后在 Web Worker 里面，导入并编译 WASM 程序，在收到消息的时候执行计算，并将结果返回给主线程。</p>
<pre><code class="language-js">import init from &#x27;./pkg/hello_wasm.js&#x27;;
import {wasm_add} from &#x27;./pkg/hello_wasm.js&#x27;;

let isWasmInit = false; //判断是否完成wasm编译

init().then(() =&gt; isWasmInit = true); //初始化Wasm（编译）

onmessage = function (m) {
    const data = m.data;
    if (isWasmInit) { //在接收到 message 时，wasm 已经完成编译。
        console.log(&#x27;Wasm init before message&#x27;);
        run();
    } else { //在接收到 message 时，wasm 没有完成编译，所以先编译再执行。
        console.log(&#x27;Wasm not init before message&#x27;);
        init().then(() =&gt; {
                run();
                isWasmInit = true;
            }
        );
    }

    function run() {
        const res = wasm_add(data[0], data[1]); //调用具体的 wasm 函数
        postMessage(res);
    }
}
</code></pre>
<p>这样，我们就实现了一个<strong>不阻塞主线程的，高性能</strong>的加法。（好像没有什么卵用</p>
<p>但是想想看，如果这是一个加密或解密算法，或者音视频转码，是不是就很有必要了？</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      WASM + Rust + WebWorker 实现计算器（\r\nintro:   \"\"\r\ndate:       2022-4-8 23:00:00\r\nauthor:     \"Mahiru\"\r\ncatalog: true\r\ntags:\r\n    - 工程开发\r\n---\r\n\r\n## WASM + Rust + WebWorker 实现高性能计算器\r\n\r\n假设我们现在需要执行一个 CPU 负载很大的运算。为了不阻塞主线程，我们希望用 Web Worker 将其放到一个新的线程中进行运算，这样就可以避免阻塞主线程。\r\n\r\n而为了提高这个运算的性能，我们希望用 Rust 编写的 WASM 程序来运算。\r\n\r\n**本文就将实现在 Web Worker 中调用 WASM 进行运算。**\r\n\r\n首先，我们来编写一段 Rust 代码，用于完成实际的计算。\r\n\r\n```rust\r\nextern crate wasm_bindgen;\r\n\r\nuse wasm_bindgen::prelude::*;\r\n\r\n#[wasm_bindgen]\r\nextern \"C\" {}\r\n\r\n#[wasm_bindgen]\r\npub fn wasm_add(a: i32, b: i32) -\u003e i32 {\r\n    a + b\r\n}\r\n```\r\n\r\n然后，将其编译为 WASM ，具体的方法参见我的上一篇博文。\r\n\r\n接下来，我们需要创建一个网页，用于测试我们的函数。\r\n\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eTestWoker\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n\u003cscript type=\"module\" src=\"script.js\"\u003e\u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n在 `script.js`里面，我们要创建一个 Web Worker。\r\n\r\n```js\r\nif (window.Worker) {\r\n    //加载worker，注意第二个参数要有，否则无法导入 module\r\n    const myWorker = new Worker('./worker.js', {type: 'module'});\r\n    myWorker.postMessage([1, 2]);//发送消息\r\n    myWorker.postMessage([3, 4]);//发送消息\r\n    setTimeout(() =\u003e {\r\n        myWorker.postMessage([7, 8])\r\n    }, 1000); //1秒后发送消息，用于在编译完成后使 worker 收到消息。\r\n    myWorker.onmessage = (m) =\u003e {\r\n        const data = m.data;\r\n        console.log('data from wasm: ' + data); //拿到 wasm 计算的结果\r\n    }\r\n}\r\n```\r\n\r\n然后在 Web Worker 里面，导入并编译 WASM 程序，在收到消息的时候执行计算，并将结果返回给主线程。\r\n\r\n```js\r\nimport init from './pkg/hello_wasm.js';\r\nimport {wasm_add} from './pkg/hello_wasm.js';\r\n\r\nlet isWasmInit = false; //判断是否完成wasm编译\r\n\r\ninit().then(() =\u003e isWasmInit = true); //初始化Wasm（编译）\r\n\r\nonmessage = function (m) {\r\n    const data = m.data;\r\n    if (isWasmInit) { //在接收到 message 时，wasm 已经完成编译。\r\n        console.log('Wasm init before message');\r\n        run();\r\n    } else { //在接收到 message 时，wasm 没有完成编译，所以先编译再执行。\r\n        console.log('Wasm not init before message');\r\n        init().then(() =\u003e {\r\n                run();\r\n                isWasmInit = true;\r\n            }\r\n        );\r\n    }\r\n\r\n    function run() {\r\n        const res = wasm_add(data[0], data[1]); //调用具体的 wasm 函数\r\n        postMessage(res);\r\n    }\r\n}\r\n```\r\n\r\n这样，我们就实现了一个**不阻塞主线程的，高性能**的加法。（好像没有什么卵用\r\n\r\n但是想想看，如果这是一个加密或解密算法，或者音视频转码，是不是就很有必要了？\r\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2022-4-8-Wasm-2.markdown"},"buildId":"ZF3YO57AemfjKbXhzWO3Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>