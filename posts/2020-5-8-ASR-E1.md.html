<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/876d048b5dab7c28.css" as="style"/><link rel="stylesheet" href="/_next/static/css/876d048b5dab7c28.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-f11614d8aa7ee555.js" defer=""></script><script src="/_next/static/chunks/pages/_app-bf55c49910772dbb.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/557-10798b428373902a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-a468c6c0f66f2931.js" defer=""></script><script src="/_next/static/ZF3YO57AemfjKbXhzWO3Q/_buildManifest.js" defer=""></script><script src="/_next/static/ZF3YO57AemfjKbXhzWO3Q/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><h2>KMP理论概要</h2>
<p>KMP字符串匹配算法是一种效率更高的字符串匹配算法。相比于传统算法，由于其主串指针不需要回溯，因此大大减少了匹配需要的时间。</p>
<p>首先，让我们看看其是如何减少重复的步骤的：</p>
<p>假如有一字符串S：</p>
<p>| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | a    | b    | c    | a    | a    | b    | a    |</p>
<p>我们想要让字符串“aaba”与其匹配。</p>
<p>那么，匹配看起来就是这样：</p>
<p>第一次匹配：</p>
<p>| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |
| a    | a    | b    | <strong>c</strong>         | a    | a    | b    | a    |
| a    | a    | b    | <strong>a(不匹配)</strong> |      |      |      |      |</p>
<p>此时指针回退，主串指针回退至2，模式串回退至1。</p>
<p>第二次匹配：</p>
<p>| 1    | 2    | 3               | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | --------------- | ---- | ---- | ---- | ---- | ---- |
| a    | a    | <strong>b</strong>           | c    | a    | a    | b    | a    |
|      | a    | <strong>a（不匹配）</strong> |      |      |      |      |      |</p>
<p>此时主串指针再次回退。</p>
<p>可以看出，我们的主串指针在匹配过程中一直在重复读取某一段内容，这是大大有损效率的。若是能使主串指针不回退，只控制模式串指针回退一段距离，这也许可以改善。</p>
<p>实际上，第二次匹配可以简化为：</p>
<p>| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |
| a    | a    | b    | <strong>c</strong>         | a    | a    | b    | a    |
|      |      |      | <strong>a(不匹配)</strong> |      |      |      |      |</p>
<p>然后是第三次匹配：</p>
<p>| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8               |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | --------------- |
| a    | a    | b    | c    | a    | a    | b    | <strong>a</strong>           |
|      |      |      |      | a    | a    | b    | <strong>a(匹配成功)</strong> |</p>
<p>那么，如何算出模式串指针应当回退多少呢？</p>
<p>根据KMP算法的核心思想，模式串T拥有一个对应表，用于记录模式串T重复的部分。</p>
<p>观察以下两个对应表：</p>
<p>| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | a    | b    | a    | a    | a    | b    | a    |
| 0    | 1    | 2    | 1    | 2    | 3    | 3    | 4    |</p>
<p>| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | c    | d    | e    | f    | g    | h    |
| 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |</p>
<p>可以看出，1号表格中，在匹配到第8个位置时，若是不匹配，只需要回到4对应的位置继续匹配就可以了，但是2号表格中，每一次匹配都必须要回到位置1重新匹配。</p>
<p>原因在于此：</p>
<p>| 1       | 2       | 3       | 4    | 5       | 6       | 7       | 8    |
| ------- | ------- | ------- | ---- | ------- | ------- | ------- | ---- |
| <em><strong>a</strong></em> | <em><strong>a</strong></em> | <em><strong>b</strong></em> | a    | <em><strong>a</strong></em> | <em><strong>a</strong></em> | <em><strong>b</strong></em> | a    |
| 0       | 1       | 2       | 1    | 2       | 3       | 3       | 4    |</p>
<p>可以看到，若是第8个字符不匹配并不影响前3个字符已经匹配成功的事实。因为5、6、7三个字符与1、2、3无异。既然我们已经匹配过a、b、c三个字符了，何必再匹配一次？</p>
<p>举例说明：</p>
<p>匹配 “aabaaaabcaabaaaba”与“aabaaaba”</p>
<p>| 1       | 2       | 3       | 4    | 5        | 6        | 7        | 8              | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |
| ------- | ------- | ------- | ---- | -------- | -------- | -------- | -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a       | a       | b       | a    | a        | a        | b        | <strong>c</strong>          | a    | a    | b    | a    | a    | a    | b    | a    |
| a       | a       | b       | a    | <strong>a</strong>    | <strong>a</strong>    | <strong>b</strong>    | <strong>a(不匹配）</strong> |      |      |      |      |      |      |      |      |
| 与5相同 | 与6相同 | 与7相同 |      | <strong>匹配</strong> | <strong>匹配</strong> | <strong>匹配</strong> |                |      |      |      |      |      |      |      |      |</p>
<p>| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8                 | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | a    | b    | a    | a    | a    | b    | <strong>c</strong>             | a    | a    | b    | a    | a    | a    | b    | a    |
|      |      |      |      | a    | a    | b    | <strong>a（继续匹配）</strong> | a    | a    | b    | a    |      |      |      |      |</p>
<p>可以看到，由于我们已经在匹配5、6、7三个字符时确定a、a、b三个字符是匹配的，那么我们就不需要在匹配前三个字符上浪费时间了。</p>
<p>那么，我们已经知道了如何使用模式串的“特性数组”来减少匹配重复字符上的浪费，但是这个数组怎样计算出来呢？</p>
<p>综合来看，我们计算此数组的目的就在于减少重复匹配，那么此数组的最大目的就是找出在制定字母之前有多少重复部分。</p>
<p>如：aabaaaba</p>
<p>| 1                                                            | 2                      | 3            | 4             | 5            | 6             | 7             | 8              |
| ------------------------------------------------------------ | ---------------------- | ------------ | ------------- | ------------ | ------------- | ------------- | -------------- |
| a                                                            | a                      | b            | a             | a            | a             | b             | a              |
| 0（因为每次匹配都是先使指针+1再匹配，若是第一个字符就不匹配，那么就使指针位置为0，匹配时从第一个开始匹配。） | 1（无论有无重复都为1） | 2（重复了a） | 1（没有重复） | 2（重复了a） | 3（重复了aa） | 3（重复了aa） | 4（重复了aab） |</p>
<p>由此，推导程序如下：</p>
<pre><code class="language-c++">std::vector&lt;int&gt; getNext(std::string in) {
        std::vector&lt;int&gt; res(in.length() + 1);
        int i = 1, j = 0;
        res[1] = 0;
        while (i &lt; in.length()) {
            if (j == 0 || in[j - 1] == in[i - 1]) {
                i++;
                j++;
                res[i] = j;
            } else
                j = res[j];
        }
        return res;
    }
</code></pre>
<h2>KMP再优化：</h2>
<p>我们已经看出KMP算法是如何减少重复匹配来减少匹配时间的。但是，是否有一种更优化的方法呢？</p>
<p>观察以下字符串：</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\r\nlayout:     post\r\ntitle:      \"KMP算法详解\"\r\nintro:      \"\"\r\ndate:       2020-5-8 11:00:00\r\nauthor:     \"Makinohara\"\r\ncatalog: true\r\ntags:\r\n    - 计算机基础\r\n---\r\n\r\n## KMP理论概要\r\n\r\nKMP字符串匹配算法是一种效率更高的字符串匹配算法。相比于传统算法，由于其主串指针不需要回溯，因此大大减少了匹配需要的时间。\r\n\r\n首先，让我们看看其是如何减少重复的步骤的：\r\n\r\n假如有一字符串S：\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | c    | a    | a    | b    | a    |\r\n\r\n我们想要让字符串“aaba”与其匹配。\r\n\r\n那么，匹配看起来就是这样：\r\n\r\n第一次匹配：\r\n\r\n| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | **c**         | a    | a    | b    | a    |\r\n| a    | a    | b    | **a(不匹配)** |      |      |      |      |\r\n\r\n此时指针回退，主串指针回退至2，模式串回退至1。\r\n\r\n第二次匹配：\r\n\r\n| 1    | 2    | 3               | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | --------------- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | a    | **b**           | c    | a    | a    | b    | a    |\r\n|      | a    | **a（不匹配）** |      |      |      |      |      |\r\n\r\n此时主串指针再次回退。\r\n\r\n可以看出，我们的主串指针在匹配过程中一直在重复读取某一段内容，这是大大有损效率的。若是能使主串指针不回退，只控制模式串指针回退一段距离，这也许可以改善。\r\n\r\n实际上，第二次匹配可以简化为：\r\n\r\n| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | **c**         | a    | a    | b    | a    |\r\n|      |      |      | **a(不匹配)** |      |      |      |      |\r\n\r\n然后是第三次匹配：\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8               |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | --------------- |\r\n| a    | a    | b    | c    | a    | a    | b    | **a**           |\r\n|      |      |      |      | a    | a    | b    | **a(匹配成功)** |\r\n\r\n那么，如何算出模式串指针应当回退多少呢？\r\n\r\n根据KMP算法的核心思想，模式串T拥有一个对应表，用于记录模式串T重复的部分。\r\n\r\n观察以下两个对应表：\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | a    | a    | a    | b    | a    |\r\n| 0    | 1    | 2    | 1    | 2    | 3    | 3    | 4    |\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | b    | c    | d    | e    | f    | g    | h    |\r\n| 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |\r\n\r\n可以看出，1号表格中，在匹配到第8个位置时，若是不匹配，只需要回到4对应的位置继续匹配就可以了，但是2号表格中，每一次匹配都必须要回到位置1重新匹配。\r\n\r\n\r\n\r\n原因在于此：\r\n\r\n| 1       | 2       | 3       | 4    | 5       | 6       | 7       | 8    |\r\n| ------- | ------- | ------- | ---- | ------- | ------- | ------- | ---- |\r\n| ***a*** | ***a*** | ***b*** | a    | ***a*** | ***a*** | ***b*** | a    |\r\n| 0       | 1       | 2       | 1    | 2       | 3       | 3       | 4    |\r\n\r\n可以看到，若是第8个字符不匹配并不影响前3个字符已经匹配成功的事实。因为5、6、7三个字符与1、2、3无异。既然我们已经匹配过a、b、c三个字符了，何必再匹配一次？\r\n\r\n举例说明：\r\n\r\n匹配 “aabaaaabcaabaaaba”与“aabaaaba”\r\n\r\n| 1       | 2       | 3       | 4    | 5        | 6        | 7        | 8              | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\r\n| ------- | ------- | ------- | ---- | -------- | -------- | -------- | -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a       | a       | b       | a    | a        | a        | b        | **c**          | a    | a    | b    | a    | a    | a    | b    | a    |\r\n| a       | a       | b       | a    | **a**    | **a**    | **b**    | **a(不匹配）** |      |      |      |      |      |      |      |      |\r\n| 与5相同 | 与6相同 | 与7相同 |      | **匹配** | **匹配** | **匹配** |                |      |      |      |      |      |      |      |      |\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8                 | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| a    | a    | b    | a    | a    | a    | b    | **c**             | a    | a    | b    | a    | a    | a    | b    | a    |\r\n|      |      |      |      | a    | a    | b    | **a（继续匹配）** | a    | a    | b    | a    |      |      |      |      |\r\n\r\n可以看到，由于我们已经在匹配5、6、7三个字符时确定a、a、b三个字符是匹配的，那么我们就不需要在匹配前三个字符上浪费时间了。\r\n\r\n那么，我们已经知道了如何使用模式串的“特性数组”来减少匹配重复字符上的浪费，但是这个数组怎样计算出来呢？\r\n\r\n综合来看，我们计算此数组的目的就在于减少重复匹配，那么此数组的最大目的就是找出在制定字母之前有多少重复部分。\r\n\r\n如：aabaaaba\r\n\r\n| 1                                                            | 2                      | 3            | 4             | 5            | 6             | 7             | 8              |\r\n| ------------------------------------------------------------ | ---------------------- | ------------ | ------------- | ------------ | ------------- | ------------- | -------------- |\r\n| a                                                            | a                      | b            | a             | a            | a             | b             | a              |\r\n| 0（因为每次匹配都是先使指针+1再匹配，若是第一个字符就不匹配，那么就使指针位置为0，匹配时从第一个开始匹配。） | 1（无论有无重复都为1） | 2（重复了a） | 1（没有重复） | 2（重复了a） | 3（重复了aa） | 3（重复了aa） | 4（重复了aab） |\r\n\r\n由此，推导程序如下：\r\n\r\n```c++\r\nstd::vector\u003cint\u003e getNext(std::string in) {\r\n        std::vector\u003cint\u003e res(in.length() + 1);\r\n        int i = 1, j = 0;\r\n        res[1] = 0;\r\n        while (i \u003c in.length()) {\r\n            if (j == 0 || in[j - 1] == in[i - 1]) {\r\n                i++;\r\n                j++;\r\n                res[i] = j;\r\n            } else\r\n                j = res[j];\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n## KMP再优化：\r\n\r\n我们已经看出KMP算法是如何减少重复匹配来减少匹配时间的。但是，是否有一种更优化的方法呢？\r\n\r\n观察以下字符串：\r\n\r\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2020-5-8-ASR-E1.md"},"buildId":"ZF3YO57AemfjKbXhzWO3Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>